# 响应 (Response)

**`response` 类**的实例用于响应 HTTP 请求。AdonisJS 支持发送 **HTML 片段**、**JSON 对象**、**流**等多种内容。可以通过 `ctx.response` 属性访问响应实例。

-----

## 发送响应 (Sending response)

发送响应**最简单**的方法是**从路由处理程序中返回值**。

```ts
import router from '@adonisjs/core/services/router'

router.get('/', async () => {
  /** 纯字符串 */
  return 'This is the homepage.'

  /** HTML 片段 */
  return '<p> This is the homepage </p>'

  /** JSON 响应 */
  return { page: 'home' }

  /** Date 对象会被转换为 ISO 字符串 */
  return new Date()
})
```

除了从路由处理程序中返回值之外，您可以使用 **`response.send(body)` 方法**来**显式**设置响应体。但是，多次调用 `response.send` 方法将**覆盖**旧的响应体，并**仅保留最新的**。

```ts
import router from '@adonisjs/core/services/router'

router.get('/', async ({ response }) => {
  /** 纯字符串 */
  response.send('This is the homepage')

  /** HTML 片段 */
  response.send('<p> This is the homepage </p>')

  /** JSON 响应 */
  response.send({ page: 'home' })

  /** Date 对象会被转换为 ISO 字符串 */
  response.send(new Date())
})
```

可以使用 **`response.status(code)` 方法**设置自定义的响应状态码。

```ts
response.status(200).send({ page: 'home' })

// 发送空的 201 响应
response.status(201).send('')
```

-----

## 流式传输内容 (Streaming content)

**`response.stream(stream, onErrorCallback)` 方法**允许将**流 (stream)** 管道传输到响应中。该方法在内部会在流结束后将其**销毁**。

`response.stream` 方法**不会设置** `content-type` 和 `content-length` 标头；您必须在流式传输内容之前**显式**设置它们。

```ts
import router from '@adonisjs/core/services/router'

router.get('/', async ({ response }) => {
  const image = fs.createReadStream('./some-file.jpg')
  // 注意：需要手动设置 Content-Type 和 Content-Length 标头
  response.stream(image) 
})
```

如果发生错误，客户端会收到一个 **500 状态码**。但是，您可以通过将**回调函数**定义为**第二个参数**来自定义错误码和消息。

```ts
const image = fs.createReadStream('./some-file.jpg')

response.stream(image, () => {
  const message = 'Unable to serve file. Try again'
  const status = 400

  return [message, status] // 返回自定义的 [消息, 状态码]
})
```

-----

## 下载文件 (Downloading files)

当您想从磁盘流式传输文件时，我们建议使用 **`response.download(filePath, generateEtag, onErrorCallback)` 方法**，而不是 `response.stream` 方法。这是因为 `download` 方法会**自动设置** `content-type` 和 `content-length` 标头。

```ts
import app from '@adonisjs/core/services/app'
import router from '@adonisjs/core/services/router'

router.get('/uploads/:file', async ({ response, params }) => {
  const filePath = app.makePath(`uploads/${params.file}`)

  response.download(filePath)
})
```

您可以选择性地为文件内容生成一个 [Etag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag)。使用 Etags 将有助于浏览器**重用**来自上一个请求的**缓存响应**（如果存在）。

```ts
const filePath = app.makePath(`uploads/${params.file}`)
const generateEtag = true // 启用 Etag 生成

response.download(filePath, generateEtag)
```

与 `response.stream` 方法类似，您可以通过将**回调函数**定义为**最后一个参数**来发送自定义错误消息和状态码。

```ts
const filePath = app.makePath(`uploads/${params.file}`)
const generateEtag = true

response.download(filePath, generateEtag, (error) => {
  if (error.code === 'ENOENT') { // 文件不存在
    return ['File does not exists', 404]
  }

  return ['Cannot download file', 400]
})
```

### 强制下载文件 (Force downloading files)

**`response.attachment(filePath, filename, generateEtag, onErrorCallback)` 方法**类似于 `response.download` 方法，但它通过设置 [Content-Disposition](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition) 标头来**强制**浏览器将文件**保存到用户计算机上**。

```ts
import app from '@adonisjs/core/services/app'
import router from '@adonisjs/core/services/router'

router.get('/uploads/:file', async ({ response, params }) => {
  const filePath = app.makePath(`uploads/${params.file}`)

  // 第二个参数是可选的，用于指定下载时的文件名
  response.attachment(filePath, 'custom-filename.jpg') 
})
```

-----

## 设置响应状态和标头 (Setting response status and headers)

### 设置状态 (Setting status)

您可以使用 **`response.status(code)` 方法**设置响应状态。调用此方法将**覆盖**现有的响应状态（如果存在）。但是，您可以使用 **`response.safeStatus(code)` 方法**，**仅当**状态为 `undefined` 时才设置它。

```ts
import router from '@adonisjs/core/services/router'

router.get('/', async ({ response }) => {
  /**
   * 将状态设置为 200
   */
  response.safeStatus(200)

  /**
   * 由于状态已设置，因此不会将状态设置为 201
   */
  response.safeStatus(201)
})
```

### 设置标头 (Setting headers)

您可以使用 **`response.header(name, value)` 方法**设置响应标头。此方法会**覆盖**现有的标头值（如果已存在）。但是，您可以使用 **`response.safeHeader(name, value)` 方法**，**仅当**标头值为 `undefined` 时才设置它。

```ts
import router from '@adonisjs/core/services/router'

router.get('/', async ({ response }) => {
  /**
   * 定义 content-type 标头
   */
  response.safeHeader('Content-type', 'text/html')

  /**
   * 由于 content-type 标头已设置，因此不会再次设置
   */
  response.safeHeader('Content-type', 'text/html')
})
```

您可以使用 **`response.append(name, value)` 方法**将值**附加**到现有标头值。

```ts
response.append('Set-cookie', 'cookie-value')
```

**`response.removeHeader(name)` 方法**用于**移除**现有标头。

```ts
response.removeHeader('Set-cookie')
```

### X-Request-Id 标头 (X-Request-Id header)

如果标头存在于当前请求中，或者如果 [生成请求 ID (Generating request ids)](https://www.google.com/search?q=%23generating-request-ids) 已启用，则该标头将存在于响应中。

-----

## 重定向 (Redirects)

**`response.redirect()` 方法**返回 [Redirect](https://github.com/adonisjs/http-server/blob/main/src/redirect.ts) 类的一个实例。Redirect 类使用**流畅 API** 来构造重定向 URL。

执行重定向的最简单方法是使用重定向路径调用 **`redirect.toPath(path)` 方法**。

```ts
import router from '@adonisjs/core/services/router'

router.get('/posts', async ({ response }) => {
  response.redirect().toPath('/articles') // 重定向到 /articles
})
```

Redirect 类还允许从**预先注册的路由**构造 URL。**`redirect.toRoute(identifier, params)` 方法**接受 [路由标识符 (route identifier)](https://www.google.com/search?q=./routing.md%23route-identifier) 作为第一个参数，并将路由参数作为第二个参数。

```ts
import router from '@adonisjs/core/services/router'

router.get('/articles/:id', async () => {}).as('articles.show') // 路由命名为 articles.show

router.get('/posts/:id', async ({ response, params }) => {
  // 重定向到命名路由 articles.show，并传递参数
  response.redirect().toRoute('articles.show', { id: params.id }) 
})
```

### 重定向回上一页 (Redirect back to the previous page)

在表单提交期间，如果出现验证错误，您可能希望将用户**重定向回上一页**。您可以使用 **`redirect.back()` 方法**来实现。

```ts
response.redirect().back()
```

### 重定向状态码 (Redirection status code)

重定向响应的默认状态是 **`302`**；您可以通过调用 **`redirect.status(code)` 方法**来更改它。

```ts
// 使用 301 永久重定向
response.redirect().status(301).toRoute('articles.show', { id: params.id }) 
```

### 带有查询字符串的重定向 (Redirect with query string)

您可以使用 **`withQs(queryObject)` 方法**将查询字符串附加到重定向 URL。该方法接受一个键值对对象并将其转换为字符串。

```ts
response.redirect().withQs({ page: 1, limit: 20 }).toRoute('articles.index')
```

要转发**当前请求 URL** 中的查询字符串，请**不带任何参数**调用 `withQs` 方法。

```ts
// 转发当前 URL 查询字符串
response.redirect().withQs().toRoute('articles.index')
```

当重定向回上一页时，`withQs` 方法将转发**上一页**的查询字符串。

```ts
// 转发上一页 URL 查询字符串
response.redirect().withQs().back()
```

-----

## 带有错误的请求中止 (Aborting request with an error)

您可以使用 **`response.abort(error, status)` 方法**通过抛出异常来**结束请求**。该方法将抛出 **`E_HTTP_REQUEST_ABORTED` 异常**并触发 [异常处理](https://www.google.com/search?q=./exception_handling.md) 流程。

```ts
router.get('posts/:id/edit', async ({ response, auth, params }) => {
  const post = await Post.findByOrFail(params.id)

  if (!auth.user.can('editPost', post)) {
    // 抛出异常，默认状态码 400
    response.abort({ message: 'Cannot edit post' }) 
  }

  // 继续执行其余逻辑
})
```

默认情况下，该异常将创建一个带有 **`400` 状态码**的 HTTP 响应。但是，您可以将**自定义状态码**指定为**第二个参数**。

```ts
// 使用自定义状态码 403
response.abort({ message: 'Cannot edit post' }, 403) 
```

-----

## 响应完成后运行动作 (Running actions after response finishes)

您可以使用 **`response.onFinish(callback)` 方法**监听 Node.js **完成将响应写入 TCP 套接字**的事件。在底层，我们使用 [on-finished](https://github.com/jshttp/on-finished) 包，因此请随时查阅该包的 README 文件以获取深入的技术解释。

```ts
router.get('posts', ({ response }) => {
  response.onFinish(() => {
    // 响应发送给客户端后的清理逻辑
  })
})
```

-----

## 访问 Node.js `res` 对象 (Accessing Node.js `res` object)

您可以使用 **`response.response` 属性**访问 [Node.js `res` 对象](https://www.google.com/search?q=%5Bhttps://nodejs.org/dist/latest-v19.x/docs/api/http.html%23class-httpserverresponse%5D\(https://nodejs.org/dist/latest-v19.x/docs/api/http.html%23class-httpserverresponse\))。

```ts
router.get('posts', ({ response }) => {
  // 打印底层的 Node.js 响应对象
  console.log(response.response) 
})
```

-----

## 响应体序列化 (Response body serialization)

使用 `response.send` 方法设置的响应体在 [作为响应写入](https://nodejs.org/dist/latest-v18.x/docs/api/http.html#responsewritechunk-encoding-callback) 到传出消息流之前，会被**序列化为字符串**。

以下是支持的数据类型及其序列化规则列表。

  * **数组和对象**：使用 [安全字符串化函数](https://github.com/poppinss/utils/blob/main/src/json/safe_stringify.ts) 进行字符串化。该方法类似于 `JSON.stringify`，但会**移除循环引用**并序列化 `BigInt` 值。
  * **数字和布尔值**：转换为字符串。
  * **Date 类的实例**：通过调用 `toISOString` 方法转换为字符串。
  * **正则表达式和错误对象**：通过调用 `toString` 方法转换为字符串。
  * **任何其他数据类型**：导致异常。

### 内容类型推断 (Content type inference)

序列化响应后，响应类会自动**推断**并设置 **`content-type`** 和 **`content-length` 标头**。

以下是设置 `content-type` 标头的规则列表。

  * 对于**数组和对象**，内容类型设置为 **`application/json`**。
  * 对于 **HTML 片段**，内容类型设置为 **`text/html`**。
  * **JSONP 响应**发送时使用 **`text/javascript`** 内容类型。
  * 对于**所有其他内容**，内容类型设置为 **`text/plain`**。

-----

## 扩展 Response 类 (Extending Response class)

您可以使用 **Macros** 或 **Getters** 向 Response 类添加自定义属性。如果您对 Macros 的概念不熟悉，请务必先阅读 [扩展 AdonisJS 指南](https://www.google.com/search?q=../concepts/extending_the_framework.md)。

```ts
import { Response } from '@adonisjs/core/http'

// 使用 Macro 添加一个普通方法
Response.macro('property', function (this: Response) {
  return value
})

// 使用 Getter 添加一个计算属性
Response.getter('property', function (this: Response) {
  return value
})
```

由于 Macros 和 Getters 是在**运行时**添加的，您必须通过 TypeScript **声明合并**来告知 TypeScript 它们的类型。

```ts
declare module '@adonisjs/core/http' {
  export interface Response {
    property: valueType // 声明新的属性及其类型
  }
}
```