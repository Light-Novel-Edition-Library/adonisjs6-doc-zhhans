# 环境变量 (Environment variables)

环境变量的作用是将秘密信息（如数据库密码、应用程序密钥或 API 密钥）存储在应用程序代码库之外。

此外，环境变量可用于针对不同环境设置不同的配置。例如，您可以在测试期间使用内存邮件发送器 (memory mailer)，在开发期间使用 SMTP 邮件发送器，并在生产环境中则使用第三方服务。

由于所有操作系统、部署平台和 CI/CD 管道都支持环境变量，因此它们已成为存储秘密信息和特定于环境的配置的事实标准 (de-facto standard)。

在本指南中，我们将学习如何在 AdonisJS 应用程序中利用环境变量。

## 读取环境变量 (Reading environment variables)

Node.js 通过 [`process.env` 全局属性](https://www.google.com/search?q=%5Bhttps://nodejs.org/dist/latest-v8.x/docs/api/process.html%23process_process_env)以对象的形式原生公开所有环境变量](https://www.google.com/search?q=https://nodejs.org/dist/latest-v8.x/docs/api/process.html%23process\_process\_env)%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%8E%9F%E7%94%9F%E5%85%AC%E5%BC%80%E6%89%80%E6%9C%89%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F)，您可以按如下方式访问它们：

```dotenv
process.env.NODE_ENV
process.env.HOST
process.env.PORT
```

-----

## 使用 AdonisJS Env 模块 (Using the AdonisJS env module)

通过 `process.env` 对象读取环境变量无需 AdonisJS 方面的任何设置，因为 Node.js 运行时原生支持它。然而，在本文档的其余部分，我们将使用 **AdonisJS Env 模块**，原因如下：

  * 能够从多个 `.env` 文件中存储和解析环境变量。
  * 在应用程序启动时立即验证环境变量。
  * 为经过验证的环境变量提供静态类型安全。

Env 模块在 `start/env.ts` 文件中实例化，您可以在应用程序的其他地方按如下方式访问它：

```ts
import env from '#start/env'

env.get('NODE_ENV')
env.get('HOST')
env.get('PORT')

// 当 PORT 未定义时，返回 3333
env.get('PORT', 3333)
```

### 与 Edge 模板共享 Env 模块 (Sharing env module with Edge templates)

如果您想在 Edge 模板中访问环境变量，则必须将 `env` 模块作为全局变量与 Edge 模板共享。

您可以在 `start` 目录中[创建一个 `view.ts` 预加载文件](https://www.google.com/search?q=../concepts/adonisrc_file.md%23preloads)，并在其中写入以下代码行：

:::note

这样做不会将 `env` 模块暴露给浏览器。`env` 模块仅在服务器端渲染期间可用。

:::

```ts
// title: start/view.ts
import env from '#start/env'
import edge from 'edge.js'

edge.global('env', env)
```

-----

## 验证环境变量 (Validating environment variables)

环境变量的验证规则是使用 `Env.create` 方法在 `start/env.ts` 文件中定义的。

当您第一次导入此文件时，验证会自动执行。通常，`start/env.ts` 文件会被项目中的其中一个配置文件导入。如果不是，则 AdonisJS 会在[引导应用程序之前](https://github.com/adonisjs/slim-starter-kit/blob/main/bin/server.ts#L34-L36)隐式导入此文件。

`Env.create` 方法接受验证模式作为键值对：

  * 键是环境变量的名称。
  * 值是执行验证的函数。它可以是自定义内联函数，也可以是预定义模式方法（如 `schema.string` 或 `schema.number`）的引用。

<!-- end list -->

```ts
import Env from '@adonisjs/core/env'

/**
 * App root 用于定位项目根目录中的 .env 文件。
 */
const APP_ROOT = new URL('../', import.meta.url)

export default await Env.create(APP_ROOT, {
  HOST: Env.schema.string({ format: 'host' }),
  PORT: Env.schema.number(),
  APP_KEY: Env.schema.string(),
  APP_NAME: Env.schema.string(),
  CACHE_VIEWS: Env.schema.boolean(),
  SESSION_DRIVER: Env.schema.string(),
  NODE_ENV: Env.schema.enum([
    'development',
    'production',
    'test'
  ] as const),
})
```

### 静态类型信息 (Static-type information)

相同的验证规则用于推断静态类型信息。当使用 env 模块时，类型信息是可用的。

## 验证器模式 API (Validator schema API)

### schema.string

`schema.string` 方法确保值是有效的字符串。空字符串验证会失败，您必须使用可选变体来允许空字符串。

```ts
{
  APP_KEY: Env.schema.string()
}

// 标记为可选
{
  APP_KEY: Env.schema.string.optional()
}

// 标记为有条件可选
{
  APP_KEY: Env.schema.string.optionalWhen(() => process.env.NODE_ENV === 'production')
}
```

可以对字符串值进行格式验证。以下是可用的格式列表：

#### host

验证值是有效的 URL 或 IP 地址。

```ts
{
  HOST: Env.schema.string({ format: 'host' })
}
```

#### url

验证值是有效的 URL。您可以选择通过允许 URL 不包含 `protocol` 或 `tld` 来使验证不那么严格。

```ts
{
  S3_ENDPOINT: Env.schema.string({ format: 'url' })

  // 允许不带协议的 URL
  S3_ENDPOINT: Env.schema.string({ format: 'url', protocol: false })

  // 允许不带顶级域名的 URL
  S3_ENDPOINT: Env.schema.string({ format: 'url', tld: false })
}
```

#### email

验证值是有效的电子邮件地址。

```ts
{
  SENDER_EMAIL: Env.schema.string({ format: 'email' })
}
```

### schema.boolean

`schema.boolean` 方法确保值是有效的布尔值。空值验证会失败，您必须使用可选变体来允许空值。

字符串表示的 `'true'`、`'1'`、`'false'` 和 `'0'` 会被转换为布尔数据类型。

```ts
{
  CACHE_VIEWS: Env.schema.boolean()
}

// 标记为可选
{
  CACHE_VIEWS: Env.schema.boolean.optional()
}

// 标记为有条件可选
{
  CACHE_VIEWS: Env.schema.boolean.optionalWhen(() => process.env.NODE_ENV === 'production')
}
```

### schema.number

`schema.number` 方法确保值是有效的数字。数字值的字符串表示会被转换为数字数据类型。

```ts
{
  PORT: Env.schema.number()
}

// 标记为可选
{
  PORT: Env.schema.number.optional()
}

// 标记为有条件可选
{
  PORT: Env.schema.number.optionalWhen(() => process.env.NODE_ENV === 'production')
}
```

### schema.enum

`schema.enum` 方法根据预定义的值之一验证环境变量。枚举选项可以指定为值数组或 TypeScript 原生枚举类型。

```ts
{
  NODE_ENV: Env
    .schema
    .enum(['development', 'production'] as const)
}

// 标记为可选
{
  NODE_ENV: Env
    .schema
    .enum
    .optional(['development', 'production'] as const)
}

// 标记为有条件可选
{
  NODE_ENV: Env
    .schema
    .enum
    .optionalWhen(
      () => process.env.NODE_ENV === 'production',
      ['development', 'production'] as const
    )
}

// 使用原生枚举
enum NODE_ENV {
  development = 'development',
  production = 'production'
}

{
  NODE_ENV: Env.schema.enum(NODE_ENV)
}
```

### 自定义函数 (Custom functions)

自定义函数可以执行模式 API 未涵盖的验证。

该函数接收环境变量的名称作为第一个参数，接收值作为第二个参数。它必须返回验证后的最终值。

```ts
{
  PORT: (name, value) => {
    if (!value) {
      throw new Error('Value for PORT is required')
    }
    
    if (isNaN(Number(value))) {
      throw new Error('Value for PORT must be a valid number')
    }

    return Number(value)
  }
}
```

-----

## 定义环境变量 (Defining environment variables)

### 在开发环境 (In development)

在开发期间，环境变量定义在 **`.env`** 文件中。Env 模块会在项目根目录中查找此文件并自动解析它（如果存在）。

```dotenv
// title: .env
PORT=3333
HOST=0.0.0.0
NODE_ENV=development
APP_KEY=sH2k88gojcp3PdAJiGDxof54kjtTXa3g
SESSION_DRIVER=cookie
CACHE_VIEWS=false
```

### 在生产环境 (In production)

建议在生产环境中**使用您的部署平台**来定义环境变量。大多数现代部署平台都对其 Web UI 中定义环境变量提供了一流的支持。

如果您的部署平台没有提供定义环境变量的方法。您可以在项目根目录或生产服务器上的其他位置创建一个 `.env` 文件。

AdonisJS 会自动从项目根目录读取 `.env` 文件。但是，当 `.env` 文件存储在其他位置时，您必须设置 `ENV_PATH` 变量。

```sh
# 尝试从项目根目录读取 .env 文件
node server.js

# 从 "/etc/secrets" 目录读取 .env 文件
ENV_PATH=/etc/secrets node server.js
```

### 在测试期间 (During tests)

特定于测试环境的环境变量必须在 **`.env.test`** 文件中定义。此文件中的值会覆盖 `.env` 文件中的值。

```dotenv
// title: .env
NODE_ENV=development
SESSION_DRIVER=cookie
ASSETS_DRIVER=vite
```

```dotenv
// title: .env.test
NODE_ENV=test
SESSION_DRIVER=memory
ASSETS_DRIVER=fake
```

```ts
// 在测试期间
import env from '#start/env'

env.get('SESSION_DRIVER') // memory
```

### 所有其他 dot-env 文件 (All other dot-env files)

除了 `.env` 文件之外，AdonisJS 还会处理来自以下 dot-env 文件的环境变量。因此，您可以选择性地创建这些文件（如果需要）。

排名最高的文件会覆盖排名靠下文件中的值。

| 排名 | 文件名 | 备注 |
| :--- | :--- | :--- |
| 1st | `.env.[NODE_ENV].local` | 为当前的 `NODE_ENV` 加载。例如，如果 `NODE_ENV` 设置为 `development`，则会加载 `.env.development.local` 文件。 |
| 2nd | `.env.local` | 在除 `test` 和 `testing` 环境之外的所有环境中加载。 |
| 3rd | `.env.[NODE_ENV]` | 为当前的 `NODE_ENV` 加载。例如，如果 `NODE_ENV` 设置为 `development`，则会加载 `.env.development` 文件。 |
| 4th | `.env` | 在所有环境中加载。当其中存储秘密信息时，您应该将此文件添加到 `.gitignore`。 |

-----

## 使用标识符进行插值 (Using identifiers for interpolation)

您可以定义和使用“标识符”来更改插值行为。标识符是环境变量值的前缀字符串，允许您自定义值的解析方式。

```ts
import { EnvParser } from '@adonisjs/env'

EnvParser.defineIdentifier('base64', (value) => {
  return Buffer.from(value, 'base64').toString()
})

const envParser = new EnvParser(`
  APP_KEY=base64:U7dbSKkdb8wjVFOTq2osaDVz4djuA7BRLdoCUJEWxak=
`)

console.log(await envParser.parse())
```

在上面的示例中，`base64:` 前缀告诉 env 解析器在返回值之前对其进行 base64 解码。

或者，您可以使用 `defineIdentifierIfMissing` 方法定义一个标识符。此方法不会覆盖现有的标识符。

```ts
EnvParser.defineIdentifierIfMissing('base64', (value) => {
  return Buffer.from(value, 'base64').toString()
})
```

:::note

您可以直接在 `start/env.ts` 文件中使用这些方法。

```ts
// title: start/env.ts
import { Env } from '@adonisjs/core/env'

Env.defineIdentifier('base64', (value) => {
  return Buffer.from(value, 'base64').toString()
})

export default await Env.create(APP_ROOT, {
  APP_KEY: Env.schema.string()
})
```

:::

## 在 dot-env 文件中使用变量 (Using variables inside the dot-env files)

在 dot-env 文件中，您可以使用变量替换语法引用其他环境变量。

在以下示例中，我们从 `HOST` 和 `PORT` 属性计算 `URL`。

```dotenv
HOST=localhost
PORT=3333
// highlight-start
URL=$HOST:$PORT
// highlight-end
```

`$` 符号之后的所有**字母**、**数字**和\*\*下划线（\_）\*\*都用于构成变量名。如果变量名包含除下划线以外的特殊字符，则必须将变量名用花括号 `{}` 包裹起来。

```dotenv
REDIS-USER=admin
REDIS-URL=localhost@${REDIS-USER}
```

### 转义 `$` 符号 (Escaping the `$` sign)

要将 `$` 符号用作值，您必须对其进行转义以防止变量替换。

```dotenv
PASSWORD=pa\$\$word
```