# 数据验证 (Validation)

AdonisJS 中的数据验证通常在**控制器级别**执行。这确保了您的应用程序在处理请求后会**立即验证用户输入**，并在响应中发送错误，以便可以显示在表单字段旁边。

一旦验证完成，您就可以使用**受信任的数据**来执行其余操作，例如数据库查询、调度队列任务、发送电子邮件等。

-----

## 选择验证库 (Choosing the validation library)

AdonisJS 核心团队创建了一个**不依赖于框架**的数据验证库，名为 [**VineJS**](https://vinejs.dev/docs/introduction)。以下是使用 VineJS 的一些原因：

  * 它是 Node.js 生态系统中**最快的验证库之一**。
  * 在运行时验证的同时，提供**静态类型安全**。
  * 它已预先配置在 `web` 和 `api` 启动工具包中。
  * 官方 AdonisJS 包会使用自定义规则扩展 VineJS。例如，**Lucid** 为 VineJS 贡献了 **`unique`** 和 **`exists`** 规则。

然而，AdonisJS 在技术上**没有强制**您使用 VineJS。您可以使用任何适合您或您的团队的验证库。只需卸载 `@vinejs/vine` 包并安装您想使用的包即可。

-----

## 配置 VineJS (Configuring VineJS)

使用以下命令安装和配置 VineJS。

另请参阅：[VineJS 文档](https://vinejs.dev)

```sh
node ace add vinejs
```

:::disclosure{title="查看 add 命令执行的步骤"}

1.  使用检测到的包管理器安装 `@vinejs/vine` 包。

2.  在 `adonisrc.ts` 文件中注册以下服务提供程序。

    ```ts
    {
      providers: [
        // ...其他提供程序
        () => import('@adonisjs/core/providers/vinejs_provider') // 注册 VineJS
      ]
    }
    ```

:::

-----

## 使用验证器 (Using validators)

VineJS 使用**验证器 (validators)** 的概念。您为应用程序可以执行的每个动作创建一个验证器。例如：为一个**创建新帖子**的动作定义一个验证器，为一个**更新帖子**的动作定义另一个验证器，也许还有一个用于**删除帖子**的验证器。

我们将使用博客作为示例，并定义用于创建/更新帖子的验证器。让我们从注册一些路由和 `PostsController` 开始。

```ts
// title: 定义路由
import router from '@adonisjs/core/services/router'

const PostsController = () => import('#controllers/posts_controller')

router.post('posts', [PostsController, 'store'])
router.put('posts/:id', [PostsController, 'update'])
```

```sh
// title: 创建控制器
node ace make:controller post store update
```

```ts
// title: 脚手架控制器
import { HttpContext } from '@adonisjs/core/http'

export default class PostsController {
  async store({}: HttpContext) {}

  async update({}: HttpContext) {}
}
```

### 创建验证器 (Creating validators)

创建 `PostsController` 并定义路由后，您可以使用以下 ace 命令创建验证器。

另请参阅：[Make validator 命令](https://www.google.com/search?q=../references/commands.md%23makevalidator)

```sh
node ace make:validator post
```

验证器创建在 **`app/validators` 目录**中。验证器文件默认是空的，您可以使用它从中导出多个验证器。每个验证器都是一个 `const` 变量，保存着 [`vine.compile`](https://www.google.com/search?q=%5Bhttps://vinejs.dev/docs/getting_started%23pre-compiling-schema%5D\(https://vinejs.dev/docs/getting_started%23pre-compiling-schema\)) 方法的结果。

在以下示例中，我们定义了 `createPostValidator` 和 `updatePostValidator`。两个验证器的模式略有不同。在创建期间，我们允许用户提供自定义的 **slug**，而在更新时我们**不允许**更新它。

:::note

不必过于担心验证器模式中的重复。我们建议您选择**易于理解的模式**，而不是不惜一切代价避免重复。[潮湿代码库类比 (wet codebase analogy)](https://www.deconstructconf.com/2019/dan-abramov-the-wet-codebase) 可能会帮助您接受重复。

:::

```ts
// title: app/validators/post_validator.ts
import vine from '@vinejs/vine'

/**
 * 验证帖子的创建操作
 */
export const createPostValidator = vine.compile(
  vine.object({
    title: vine.string().trim().minLength(6),
    slug: vine.string().trim(),
    description: vine.string().trim().escape() // 允许自定义 slug
  })
)

/**
 * 验证帖子的更新操作
 */
export const updatePostValidator = vine.compile(
  vine.object({
    title: vine.string().trim().minLength(6),
    description: vine.string().trim().escape() // 不允许更新 slug
  })
)
```

### 在控制器中使用验证器 (Using validators inside controllers)

让我们回到 `PostsController` 并使用验证器来验证请求体。您可以使用 `request.all()` 方法访问请求体。

```ts
import { HttpContext } from '@adonisjs/core/http'
// 导入验证器
import {
  createPostValidator,
  updatePostValidator
} from '#validators/post_validator' 

export default class PostsController {
  async store({ request }: HttpContext) {
    // 获取所有请求数据 (body + qs + files)
    const data = request.all() 
    // 验证数据，如果失败会抛出异常
    const payload = await createPostValidator.validate(data) 
    return payload // 返回已验证且类型安全的数据
  }

  async update({ request }: HttpContext) {
    const data = request.all()
    const payload = await updatePostValidator.validate(data)
    return payload
  }
}
```

就是这样！在控制器中验证用户输入只需两行代码。验证后的输出具有从模式推断出的**静态类型信息**。

此外，您**不必**将 `validate` 方法调用包装在 `try/catch` 中。因为在发生错误的情况下，AdonisJS 将**自动将错误转换为 HTTP 响应**。

-----

## 错误处理 (Error handling)

[HttpExceptionHandler](https://www.google.com/search?q=./exception_handling.md) 将**自动**将验证错误转换为 HTTP 响应。异常处理程序使用**内容协商**，并根据 [`Accept`](https://www.google.com/search?q=%5Bhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept%5D\(https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept\)) 标头的值返回响应。

:::tip

您可能希望查看 [ExceptionHandler 源代码](https://github.com/adonisjs/http-server/blob/main/src/exception_handler.ts#L343-L345)，了解验证异常是如何转换为 HTTP 响应的。

此外，**session 中间件** [重写了 `renderValidationErrorAsHTML` 方法](https://www.google.com/search?q=%5Bhttps://github.com/adonisjs/session/blob/main/src/session_middleware.ts%23L30-L37%5D\(https://github.com/adonisjs/session/blob/main/src/session_middleware.ts%23L30-L37\))，并使用 **Flash 消息**与表单共享验证错误。

:::

  * 带有 **`Accept=application/json`** 标头的 HTTP 请求将收到一个使用 [SimpleErrorReporter](https://github.com/vinejs/vine/blob/main/src/reporters/simple_error_reporter.ts) 创建的**错误消息数组**。
  * 带有 **`Accept=application/vnd.api+json`** 标头的 HTTP 请求将收到一个根据 [JSON API](https://jsonapi.org/format/#errors) 规范格式化的**错误消息数组**。
  * 使用 [session 包](https://www.google.com/search?q=./session.md) **服务器渲染的表单**将通过 [session flash 消息](https://www.google.com/search?q=./session.md%23validation-errors-and-flash-messages) 接收错误。
  * **所有其他请求**将以纯文本形式接收错误。

-----

## `request.validateUsing` 方法

在控制器中执行验证的**推荐方法**是使用 **`request.validateUsing(validator, options)` 方法**。使用 `request.validateUsing` 方法时，您**不必显式**定义验证数据；**请求体**、**查询字符串值**和**文件**会**合并**在一起并作为数据传递给验证器。

```ts
import { HttpContext } from '@adonisjs/core/http'
import {
  createPostValidator,
  updatePostValidator
} from '#validators/posts_validator'

export default class PostsController {
  async store({ request }: HttpContext) {
    // 推荐方式：自动使用 request.all() 作为验证数据
    const payload = await request.validateUsing(createPostValidator) 
  }

  async update({ request }: HttpContext) {
    // 推荐方式：自动使用 request.all() 作为验证数据
    const payload = await request.validateUsing(updatePostValidator)
  }
}
```

### 验证 cookies、标头和路由参数 (Validating cookies, headers and route params)

使用 `request.validateUsing` 方法时，您可以如下验证 **cookies**、**headers** 和 **route params**。

```ts
const validator = vine.compile(
  vine.object({
    // Fields in request body, query string, and files
    username: vine.string(),
    password: vine.string(),

    // 验证 cookies：自动从 ctx.request.cookies() 获取
    cookies: vine.object({
      session: vine.string().optional(),
    }),

    // 验证 headers：自动从 ctx.request.headers() 获取
    headers: vine.object({
      'accept-language': vine.string().optional(),
    }),

    // 验证 route params：自动从 ctx.request.params() 获取
    params: vine.object({
      id: vine.number(),
    }),
  })
)

// request.validateUsing 会将 cookies, headers 和 params 字段注入到待验证的数据中
await request.validateUsing(validator) 
```

-----

## 向验证器传递元数据 (Passing metadata to validators)

由于验证器是在**请求生命周期之外**定义的，它们无法直接访问请求数据。这通常是好的，因为它使验证器可以在 HTTP 请求生命周期之外**重用**。

但是，如果验证器需要访问某些**运行时数据**，您必须在调用 `validate` 方法时将其作为**元数据 (metadata)** 传递。

让我们以 **`unique` 验证规则**为例。我们希望确保用户电子邮件在数据库中是唯一的，但要**跳过当前登录用户**的行。

```ts
export const updateUserValidator = vine
  .compile(
    vine.object({
      email: vine.string().unique(async (db, value, field) => {
        const user = await db
          .from('users')
          // 排除当前用户的 ID
          .whereNot('id', field.meta.userId) 
          .where('email', value)
          .first()
        return !user
      })
    })
  )
```

在上面的示例中，我们通过 **`meta.userId`** 属性访问当前登录的用户。让我们看看如何在 HTTP 请求期间传递 `userId`。

```ts
async update({ request, auth }: HttpContext) {
  await request.validateUsing(
    updateUserValidator,
    // 第二个参数用于传递配置和元数据
    { 
      meta: {
        userId: auth.user!.id // 传递 userId 作为元数据
      }
    }
  )
}
```

### 使元数据类型安全 (Making metadata type-safe)

在前面的示例中，我们必须记住在验证期间传递 `meta.userId`。如果能让 TypeScript 提醒我们就更好了。

在以下示例中，我们使用 **`vine.withMetaData<T>()` 函数**来定义我们期望在模式中使用的元数据的**静态类型**。

```ts
export const updateUserValidator = vine
  // 定义元数据的类型，TypeScript 会强制要求传递此结构
  .withMetaData<{ userId: number }>() 
  .compile(
    vine.object({
      email: vine.string().unique(async (db, value, field) => {
        const user = await db
          .from('users')
          .whereNot('id', field.meta.userId) // meta.userId 现在是类型安全的
          .where('email', value)
          .first()
        return !user
      })
    })
  )
```

请注意，VineJS **不会**在运行时验证元数据。但是，如果您想这样做，您可以将一个回调函数传递给 `withMetaData` 方法并手动执行验证。

```ts
vine.withMetaData<{ userId: number }>((meta) => {
  // 手动验证元数据
})
```

-----

## 配置 VineJS (Configuring VineJS)

您可以在 `start` 目录下创建一个 [**preload 文件**](https://www.google.com/search?q=../concepts/adonisrc_file.md%23preloads) 来为 VineJS 配置**自定义错误消息**或使用**自定义错误报告器**。

```sh
node ace make:preload validator
```

在以下示例中，我们 [定义自定义错误消息](https://vinejs.dev/docs/custom_error_messages)。

```ts
// title: start/validator.ts
import vine, { SimpleMessagesProvider } from '@vinejs/vine'

// 设置自定义消息提供程序
vine.messagesProvider = new SimpleMessagesProvider({ 
  // 适用于所有字段
  'required': 'The {{ field }} field is required',
  'string': 'The value of {{ field }} field must be a string',
  'email': 'The value is not a valid email address',

  // 仅适用于 username 字段
  'username.required': 'Please choose a username for your account',
})
```

在以下示例中，我们 [注册自定义错误报告器](https://vinejs.dev/docs/error_reporter)。

```ts
// title: start/validator.ts
import vine, { SimpleMessagesProvider } from '@vinejs/vine'
import { JSONAPIErrorReporter } from '../app/validation_reporters.js'

// 设置自定义错误报告器
vine.errorReporter = () => new JSONAPIErrorReporter() 
```

-----

## AdonisJS 贡献的规则 (Rules contributed by AdonisJS)

以下是 AdonisJS 贡献的 VineJS 规则列表。

  * **`vine.file`** [文件模式类型](https://github.com/adonisjs/core/blob/main/providers/vinejs_provider.ts) 由 AdonisJS 核心包添加。

-----

## 接下来是什么？ (What's next?)

  * 了解有关在 VineJS 中使用 [自定义消息](https://vinejs.dev/docs/custom_error_messages) 的更多信息。
  * 了解有关在 VineJS 中使用 [错误报告器](https://vinejs.dev/docs/error_reporter) 的更多信息。
  * 阅读 VineJS [模式 API](https://vinejs.dev/docs/schema_101) 文档。
  * 使用 [i18n 翻译](https://www.google.com/search?q=../digging_deeper/i18n.md%23translating-validation-messages) 来定义验证错误消息。