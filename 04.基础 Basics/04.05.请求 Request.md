# 请求 (Request)

**`request` 类**的实例保存了正在进行的 HTTP 请求的数据，包括**请求体 (request body)**、**上传文件的引用**、**Cookie**、**请求头 (request headers)** 等等。可以通过 `ctx.request` 属性访问请求实例。

-----

## 查询字符串和路由参数 (Query string and route params)

**`request.qs()`** 方法返回解析后的**查询字符串**作为一个对象。

```ts
import router from '@adonisjs/core/services/router'

router.get('posts', async ({ request }) => {
  /*
   * URL: /?sort_by=id&direction=desc
   * qs: { sort_by: 'id', direction: 'desc' }
   */
  const queryString = request.qs()
})
```

**`request.params()`** 方法返回 [路由参数 (Route params)](https://www.google.com/search?q=./routing.md%23route-params) 的一个对象。

```ts
import router from '@adonisjs/core/services/router'

router.get('posts/:slug/comments/:id', async ({ request }) => {
  /*
   * URL: /posts/hello-world/comments/2
   * params: { slug: 'hello-world', id: '2' }
   */
  const routeParams = request.params()
})
```

您可以使用 **`request.param(name)`** 方法访问单个参数。

```ts
import router from '@adonisjs/core/services/router'

router.get('posts/:slug/comments/:id', async ({ request }) => {
  const slug = request.param('slug')
  const commentId = request.param('id')
})
```

-----

## 请求体 (Request body)

AdonisJS 使用注册在 `start/kernel.ts` 文件中的 [**body-parser 中间件**](https://www.google.com/search?q=../basics/body_parser.md) 来解析请求体。

您可以使用 **`request.body()`** 方法访问请求体。它将解析后的请求体作为一个对象返回。

```ts
import router from '@adonisjs/core/services/router'

router.post('/', async ({ request }) => {
  console.log(request.body())
})
```

**`request.all()`** 方法返回**请求体和查询字符串**的**合并副本**。

```ts
import router from '@adonisjs/core/services/router'

router.post('/', async ({ request }) => {
  console.log(request.all())
})
```

### 挑选值 (Cherry-picking values)

**`request.input`**、**`request.only`** 和 **`request.except`** 方法可以从请求数据中**挑选特定属性**。所有这些挑选方法都会**同时**在**请求体和查询字符串**中查找值。

**`request.only(keys)`** 方法返回一个**仅包含**所提及属性的对象。

```ts
import router from '@adonisjs/core/services/router'

router.post('login', async ({ request }) => {
  const credentials = request.only(['email', 'password'])

  console.log(credentials) // 仅包含 email 和 password
})
```

**`request.except(keys)`** 方法返回一个**排除**所提及属性的对象。

```ts
import router from '@adonisjs/core/services/router'

router.post('register', async ({ request }) => {
  const userDetails = request.except(['password_confirmation'])

  console.log(userDetails) // 排除 password_confirmation
})
```

**`request.input(key, defaultValue)`** 方法返回特定属性的值。您可以选择将**默认值**作为第二个参数传入。当实际值缺失时，将返回该默认值。

```ts
import router from '@adonisjs/core/services/router'

router.post('comments', async ({ request }) => {
  const email = request.input('email')
  const commentBody = request.input('body')
  // 如果 'source' 缺失，则默认为 'website'
  const source = request.input('source', 'website') 
})
```

### 类型安全的请求体 (Type-safe request body)

默认情况下，AdonisJS 不会对 `request.all`、`request.body` 或挑选方法**强制执行数据类型**，因为它无法提前知道请求体的预期内容。

为了确保**类型安全**，您可以使用 [**验证器 (validator)**](https://www.google.com/search?q=./validation.md) 来验证和解析请求体，确保所有值都正确并匹配预期的类型。

-----

## 请求 URL (Request URL)

**`request.url(includeQueryString)`** 方法返回相对于主机名的**请求 URL**。默认情况下，返回值**不包含查询字符串**。但是，您可以调用 `request.url(true)` 来获取包含查询字符串的 URL。

```ts
import router from '@adonisjs/core/services/router'

router.get('/users', async ({ request }) => {
  /*
   * URL: /users?page=1&limit=20
   * url(): /users
   */
  request.url()

  /*
   * URL: /users?page=1&limit=20
   * url(true): /users?page=1&limit=20
   */
  request.url(true) // 返回查询字符串
})
```

**`request.completeUrl(includeQueryString)`** 方法返回**完整的 URL**，**包括主机名**。同样，除非明确告知，否则返回值不包括查询字符串。

```ts
import router from '@adonisjs/core/services/router'

router.get('/users', async ({ request }) => {
  // e.g., https://example.com/users
  request.completeUrl() 
  // e.g., https://example.com/users?page=1&limit=20
  request.completeUrl(true) // 返回查询字符串
})
```

-----

## 请求头 (Request headers)

**`request.headers()`** 方法将请求头作为一个对象返回。

```ts
import router from '@adonisjs/core/services/router'

router.get('/', async ({ request }) => {
  console.log(request.headers())
})
```

您可以使用 **`request.header(name)`** 方法访问单个请求头的值。

```ts
import router from '@adonisjs/core/services/router'

router.get('/', async ({ request }) => {
  request.header('x-request-id')

  // 标头名称不区分大小写
  request.header('X-REQUEST-ID')
})
```

-----

## 请求方法 (Request method)

**`request.method()`** 方法返回当前请求的 HTTP 方法。当 [表单方法欺骗](https://www.google.com/search?q=%23form-method-spoofing) 启用时，此方法返回**被欺骗的方法**，您可以使用 **`request.intended()`** 方法获取**原始请求方法**。

```ts
import router from '@adonisjs/core/services/router'

router.patch('posts', async ({ request }) => {
  /**
   * 用于路由匹配的方法 (可能是被欺骗的，如 PATCH)
   */
  console.log(request.method())

  /**
   * 实际的请求方法 (如 POST)
   */
  console.log(request.intended())
})
```

-----

## 用户 IP 地址 (User IP Address)

**`request.ip()`** 方法返回当前 HTTP 请求的**用户 IP 地址**。此方法依赖于代理服务器（如 Nginx 或 Caddy）设置的 [`X-Forwarded-For`](https://www.google.com/search?q=%5Bhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For%5D\(https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For\)) 标头。

:::note

阅读 [配置受信任的代理](https://www.google.com/search?q=%23configuring-trusted-proxies) 部分以配置您的应用程序应该信任的代理。

:::

```ts
import router from '@adonisjs/core/services/router'

router.get('/', async ({ request }) => {
  console.log(request.ip())
})
```

**`request.ips()`** 方法返回由中间代理设置的**所有 IP 地址**的数组。该数组按**最受信任到最不受信任**的 IP 地址排序。

```ts
import router from '@adonisjs/core/services/router'

router.get('/', async ({ request }) => {
  console.log(request.ips())
})
```

### 定义自定义 `getIp` 方法 (Defining a custom `getIp` method)

如果受信任代理设置不足以确定正确的 IP 地址，您可以实现自定义的 **`getIp` 方法**。

该方法在 `config/app.ts` 文件中的 **`http` 设置对象**内定义。

```ts
export const http = defineConfig({
  getIp(request) {
    // 尝试使用 X-Real-Ip 标头
    const ip = request.header('X-Real-Ip') 
    if (ip) {
      return ip
    }

    // 否则回退到默认的 ips[0]
    return request.ips()[0] 
  }
})
```

-----

## 内容协商 (Content negotiation)

AdonisJS 通过解析所有常用的 `Accept` 标头，提供了多种用于**内容协商**的方法。例如，您可以使用 **`request.types()`** 方法获取给定请求接受的所有**内容类型列表**。

`request.types` 方法的返回值按**客户端的偏好顺序**（最优先的在前）排序。

```ts
import router from '@adonisjs/core/services/router'

router.get('/', async ({ request }) => {
  // e.g., [ 'text/html', 'application/xhtml+xml', 'application/json' ]
  console.log(request.types()) 
})
```

以下是内容协商方法的完整列表。

| 方法 | 使用的 HTTP 标头 |
| :--- | :--- |
| types | [Accept](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept) |
| languages | [Accept-language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language) |
| encodings | [Accept-encoding](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding) |
| charsets | [Accept-charset](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Charset) |

有时您想根据**服务器可以支持的内容类型**来查找首选的内容类型。

为此，您可以使用 **`request.accepts(supportedTypes)` 方法**。该方法接受一个**支持的内容类型数组**，并在检查 `Accept` 标头后返回**最匹配**的一个。如果找不到匹配项，则返回 **`null`**。

```ts
import router from '@adonisjs/core/services/router'

router.get('posts', async ({ request, view }) => {
  const posts = [
    { title: 'Adonis 101' },
  ]

  const bestMatch = request.accepts(['html', 'json']) // 服务器支持 html 和 json

  switch (bestMatch) {
    case 'html':
      return view.render('posts/index', { posts }) // 客户端接受 HTML，渲染视图
    case 'json':
      return posts // 客户端接受 JSON，返回 JSON 数据
    default:
      // 没有匹配或默认处理
      return view.render('posts/index', { posts })
  }
})
```

类似于 `request.accepts`，以下方法可用于查找其他 `Accept` 标头的首选值。

```ts
// 首选语言
const language = request.language(['fr', 'de'])

// 首选编码
const encoding = request.encoding(['gzip', 'br'])

// 首选字符集
const charset = request.charset(['utf-8', 'hex', 'ascii'])
```

-----

## 生成请求 ID (Generating request ids)

请求 ID (Request ids) 通过为每个 HTTP 请求分配一个**唯一 ID**，帮助您从日志中 [调试和跟踪应用程序问题](https://blog.heroku.com/http_request_id_s_improve_visibility_across_the_application_stack)。默认情况下，请求 ID 创建是**禁用**的。但是，您可以在 `config/app.ts` 文件中启用它。

:::note

请求 ID 是使用 [cuid2](https://github.com/paralleldrive/cuid2) 包生成的。在生成 ID 之前，我们会检查 `X-Request-Id` 请求标头并使用其值（如果存在）。

:::

```ts
// title: config/app.ts
export const http = defineConfig({
  generateRequestId: true // 启用请求 ID 生成
})
```

启用后，您可以使用 **`request.id()`** 方法访问该 ID。

```ts
router.get('/', ({ request }) => {
  // e.g., ckk9oliws0000qt3x9vr5dkx7
  console.log(request.id())
})
```

**相同的请求 ID** 也会添加到使用 `ctx.logger` 实例生成的所有日志中。

```ts
router.get('/', ({ logger }) => {
  // { msg: 'hello world', request_id: 'ckk9oliws0000qt3x9vr5dkx7' }
  logger.info('hello world')
})
```

-----

## 配置受信任的代理 (Configuring trusted proxies)

大多数 Node.js 应用程序部署在像 **Nginx** 或 **Caddy** 这样的**代理服务器**后面。因此，我们必须依赖 **`X-Forwarded-Host`**、**`X-Forwarded-For`** 和 **`X-Forwarded-Proto`** 等 HTTP 标头来了解发起 HTTP 请求的**真实终端客户端**。

**仅当**您的 AdonisJS 应用程序**信任源 IP 地址**时，才会使用这些标头。

您可以使用 **`http.trustProxy`** 配置选项在 `config/app.ts` 文件中配置要信任的 IP 地址。

```ts
import proxyAddr from 'proxy-addr'

export const http = defineConfig({
  // 信任本地主机 IP 地址
  trustProxy: proxyAddr.compile(['127.0.0.1/8', '::1/128']) 
})
```

`trustProxy` 的值也可以是**函数**。如果 IP 地址受信任，该方法应返回 `true`；否则，返回 `false`。

```ts
export const http = defineConfig({
  trustProxy: (address) => {
    // 仅信任这两个特定地址
    return address === '127.0.0.1' || address === '123.123.123.123'
  }
})
```

如果您在与应用程序代码相同的服务器上运行 Nginx，则需要信任**环回 IP 地址**，即 `127.0.0.1`。

```ts
import proxyAddr from 'proxy-addr'

export const http = defineConfig({
  trustProxy: proxyAddr.compile('loopback')
})
```

如果您的应用程序**只能通过负载均衡器访问**，并且您没有该负载均衡器的 IP 地址列表。那么，您可以通过定义一个**始终返回 `true` 的回调函数**来信任代理服务器。

```ts
export const http = defineConfig({
  trustProxy: () => true
})
```

-----

## 配置查询字符串解析器 (Configuring query string parser)

来自请求 URL 的查询字符串是使用 **[qs](http://npmjs.com/qs) 模块**解析的。您可以在 `config/app.ts` 文件中配置解析器设置。

[查看所有可用选项的列表](https://github.com/adonisjs/http-server/blob/main/src/types/qs.ts#L11)。

```ts
export const http = defineConfig({
  qs: {
    parse: {
      // qs 解析器的配置
    },
  }
})
```

-----

## 表单方法欺骗 (Form method spoofing)

HTML 表单上的表单方法只能设置为 **`GET`** 或 **`POST`**，这使得利用 [restful HTTP 方法](https://restfulapi.net/http-methods/) 变得不可能。

然而，AdonisJS 允许您使用**表单方法欺骗**来解决此限制。表单方法欺骗是一个花哨的术语，指的是通过 **`_method` 查询字符串**来指定表单方法。

要使方法欺骗起作用，您必须将表单 action 设置为 **`POST`** 并在 `config/app.ts` 文件中**启用该功能**。

```ts
// title: config/app.ts
export const http = defineConfig({
  allowMethodSpoofing: true, // 启用方法欺骗
})
```

启用后，您可以如下欺骗表单方法。

```html
<form method="POST" action="/articles/1?_method=PUT">
  </form>
```

```html
<form method="POST" action="/articles/1?_method=DELETE">
  </form>
```

-----

## 扩展 Request 类 (Extending Request class)

您可以使用 **Macros** 或 **Getters** 向 Request 类添加自定义属性。如果您对 Macros 的概念不熟悉，请务必先阅读 [扩展 AdonisJS 指南](https://www.google.com/search?q=../concepts/extending_the_framework.md)。

```ts
import { Request } from '@adonisjs/core/http'

// 使用 Macro 添加一个普通方法
Request.macro('property', function (this: Request) {
  return value
})

// 使用 Getter 添加一个计算属性
Request.getter('property', function (this: Request) {
  return value
})
```

由于 Macros 和 Getters 是在**运行时**添加的，您必须通过 TypeScript **声明合并**来告知 TypeScript 它们的类型。

```ts
declare module '@adonisjs/core/http' {
  export interface Request {
    property: valueType // 声明新的属性及其类型
  }
}
```