# 控制器 (Controllers)

HTTP 控制器提供了一个**抽象层**，用于将路由处理程序组织到**专门的文件**中。您可以将所有的请求处理逻辑移到控制器类中，而不是全部在路由文件中表达。

控制器存储在 `./app/controllers` 目录中，每个控制器都表示为一个普通的 JavaScript 类。您可以通过运行以下命令来创建一个新的控制器。

另请参阅：[Make controller 命令](https://www.google.com/search?q=../references/commands.md%23makecontroller)

```sh
node ace make:controller users
```

新创建的控制器会搭建好 `class` 声明的骨架，您可以手动在其中创建方法。在这个示例中，让我们创建一个 `index` 方法并返回一个用户数组。

```ts
// title: app/controllers/users_controller.ts  
export default class UsersController {
  index() {
    return [
      {
        id: 1,
        username: 'virk',
      },
      {
        id: 2,
        username: 'romain',
      },
    ]
  }
}
```

最后，让我们将这个控制器绑定到一条路由。我们将使用 `#controllers` 别名导入控制器。别名是使用 [Node.js 的子路径导入功能](https://www.google.com/search?q=../getting_started/folder_structure.md%23the-sub-path-imports) 定义的。

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'
// 懒加载控制器
const UsersController = () => import('#controllers/users_controller')

router.get('users', [UsersController, 'index'])
```

您可能已经注意到，我们没有创建控制器类的实例，而是直接将其传递给路由。这样做允许 AdonisJS：

  * 为每个请求创建一个**全新的控制器实例**。
  * 并且使用 [IoC 容器](https://www.google.com/search?q=../concepts/dependency_injection.md) **构造**该类，这使您能够利用**自动依赖注入**。

您还可以注意到，我们正在使用一个函数**懒加载 (lazy-loading)** 控制器。

:::warning

当您使用 [HMR (热模块重载)](https://www.google.com/search?q=../concepts/hmr.md) 时，需要**懒加载控制器**。

:::

随着代码库的增长，您会注意到它开始影响应用程序的启动时间。一个常见原因是：在路由文件内导入**所有**控制器。

由于控制器处理 HTTP 请求，它们通常会导入其他模块，例如模型、验证器或第三方包。结果是，您的路由文件成为导入整个代码库的中心点。

懒加载很简单，只需将导入语句移到函数后面，并使用**动态导入**即可。

:::tip

您可以使用我们的 [ESLint 插件](https://github.com/adonisjs/tooling-config/tree/main/packages/eslint-plugin) 来强制执行并**自动将标准的控制器导入转换为懒加载的动态导入**。

:::

### 使用“魔法字符串” (Using magic strings)

另一种懒加载控制器的方法是将控制器及其方法**引用为字符串**。我们称之为**魔法字符串 (magic string)**，因为字符串本身没有语义，只是路由器在幕后使用它来查找和导入控制器。

在以下示例中，路由文件内没有任何导入语句，我们将控制器导入路径 + 方法以字符串形式绑定到路由。

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'

// 魔法字符串引用
router.get('users', '#controllers/users_controller.index') 
```

魔法字符串的唯一缺点是它们**不是类型安全的**。如果您的导入路径中出现拼写错误，您的编辑器将不会给出任何反馈。

优点是，魔法字符串可以清除路由文件内因导入语句而产生的**所有视觉干扰**。

使用魔法字符串是主观的，您可以决定是个人使用还是团队使用。

-----

## 单一行为控制器 (Single action controllers)

AdonisJS 提供了一种定义**单一行为控制器**的方法。这是一种将功能封装到命名清晰的类中的有效方式。为此，您需要在控制器内定义一个 **`handle` 方法**。

```ts
// title: app/controllers/register_newsletter_subscription_controller.ts
export default class RegisterNewsletterSubscriptionController {
  handle() {
    // ... 处理订阅逻辑
  }
}
```

然后，您可以使用以下方式在路由上引用该控制器。

```ts
// title: start/routes.ts
// 仅传递控制器类本身
router.post('newsletter/subscriptions', [RegisterNewsletterSubscriptionController]) 
```

-----

## HTTP 上下文 (HTTP context)

控制器方法接收 **`HttpContext`** 类的一个实例作为**第一个参数**。

```ts
// title: app/controllers/users_controller.ts
import type { HttpContext } from '@adonisjs/core/http'

export default class UsersController {
  index(context: HttpContext) {
    // ...
  }
}
```

-----

## 依赖注入 (Dependency injection)

控制器类是使用 [IoC 容器](https://www.google.com/search?q=../concepts/dependency_injection.md) 实例化的；因此，您可以在控制器**构造函数**或**控制器方法**内进行类型提示依赖项。

假设您有一个 `UserService` 类，您可以按如下方式在控制器中注入它的实例。

```ts
// title: app/services/user_service.ts
export class UserService {
  all() {
    // 从数据库返回用户
  }
}
```

```ts
// title: app/controllers/users_controller.ts
import { inject } from '@adonisjs/core'
import UserService from '#services/user_service'

@inject() // 启用构造函数注入
export default class UsersController {
  constructor(
    private userService: UserService // 注入 UserService
  ) {}

  index() {
    return this.userService.all()
  }
}
```

### 方法注入 (Method injection)

您可以使用[方法注入](https://www.google.com/search?q=../concepts/dependency_injection.md%23using-method-injection)直接在控制器方法内注入 `UserService` 的实例。在这种情况下，您必须在方法名称上应用 **`@inject` 装饰器**。

传递给控制器方法的**第一个参数**始终是 [`HttpContext`](https://www.google.com/search?q=../concepts/http_context.md)。因此，您必须将 `UserService` 作为**第二个参数**进行类型提示。

```ts
// title: app/controllers/users_controller.ts
import { inject } from '@adonisjs/core'
import { HttpContext } from '@adonisjs/core/http'

import UserService from '#services/user_service'

export default class UsersController {
  @inject() // 启用方法注入
  index(ctx: HttpContext, userService: UserService) { // HttpContext 是第一个参数，UserService 是第二个
    return userService.all()
  }
}
```

### 依赖树 (Tree of dependencies)

依赖项的自动解析**不仅限于控制器**。注入到控制器中的任何类也可以进行类型提示依赖项，IoC 容器将为您构建**依赖树**。

例如，让我们修改 `UserService` 类，使其接受 `HttpContext` 的实例作为构造函数依赖项。

```ts
// title: app/services/user_service.ts
import { inject } from '@adonisjs/core'
import { HttpContext } from '@adonisjs/core/http'

@inject()
export class UserService {
  constructor(
    private ctx: HttpContext // 注入 HttpContext
  ) {}

  all() {
    console.log(this.ctx.auth.user)
    // 从数据库返回用户
  }
}
```

进行此更改后，`UserService` 将自动接收 `HttpContext` 类的实例。此外，控制器中**无需任何更改**。

-----

## 资源驱动的控制器 (Resource-driven controllers)

对于传统的 [RESTful](https://en.wikipedia.org/wiki/Representational_state_transfer) 应用程序，控制器应仅设计用于管理**单个资源**。资源通常是应用程序中的一个实体，例如**用户资源 (User resource)** 或**帖子资源 (Post resource)**。

让我们以 Post 资源为例，定义处理其 **CRUD** 操作的端点。我们将从首先创建一个控制器开始。

您可以使用 `make:controller` ace 命令并加上 **`--resource` 标志**来创建资源的控制器，它会搭建包含以下方法的控制器骨架。

```sh
node ace make:controller posts --resource
```

```ts
// title: app/controllers/posts_controller.ts
import type { HttpContext } from '@adonisjs/core/http'

export default class PostsController {
  /**
   * 返回所有帖子的列表或对其进行分页
   */
  async index({}: HttpContext) {}

  /**
   * 渲染用于创建新帖子的表单。
   *
   * 如果您正在创建 API 服务器，则不需要。
   */
  async create({}: HttpContext) {}

  /**
   * 处理表单提交以创建新帖子
   */
  async store({ request }: HttpContext) {}

  /**
   * 通过 id 显示单个帖子。
   */
  async show({ params }: HttpContext) {}

  /**
   * 渲染用于通过 id 编辑现有帖子的表单。
   *
   * 如果您正在创建 API 服务器，则不需要。
   */
  async edit({ params }: HttpContext) {}

  /**
   * 处理表单提交以通过 id 更新特定帖子
   */
  async update({ params, request }: HttpContext) {}

  /**
   * 处理表单提交以通过 id 删除特定帖子。
   */
  async destroy({ params }: HttpContext) {}
}
```

接下来，让我们使用 **`router.resource` 方法**将 `PostsController` 绑定到**资源路由**。该方法接受**资源名称**作为第一个参数，**控制器引用**作为第二个参数。

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'
const PostsController = () => import('#controllers/posts_controller')

// 创建一组资源路由
router.resource('posts', PostsController)
```

以下是 `resource` 方法注册的路由列表。您可以通过运行 `node ace list:routes` 命令查看此列表。

### 嵌套资源 (Nested resources)

可以通过使用**点 `.` 分隔符**指定父资源和子资源名称来创建**嵌套资源**。

在以下示例中，我们为嵌套在 `posts` 资源下的 `comments` 资源创建路由。

```ts
router.resource('posts.comments', CommentsController)
```

### 浅层资源 (Shallow resources)

使用嵌套资源时，子资源的路由总是以**父资源名称及其 id** 为前缀。例如：

  * `/posts/:post_id/comments` 路由显示给定帖子的所有评论列表。
  * `/posts/:post_id/comments/:id` 路由通过其 id 显示单个评论。

在第二条路由中，`/posts/:post_id` 的存在是**无关紧要的**，因为您可以直接通过评论的 id 查找评论。

**浅层资源 (Shallow resource)** 通过**尽可能保持 URL 结构扁平**来注册其路由。这次，让我们将 `posts.comments` 注册为浅层资源。

```ts
router.shallowResource('posts.comments', CommentsController)
```

### 命名资源路由 (Naming resource routes)

使用 `router.resource` 方法创建的路由是根据**资源名称**和**控制器操作**命名的。首先，我们将资源名称转换为**下划线命名法 (snake case)**，并使用点 `.` 分隔符连接操作名称。

| 资源 | 操作名称 | 路由名称 |
| :--- | :--- | :--- |
| posts | index | `posts.index` |
| userPhotos | index | `user_photos.index` |
| group-attributes | show | `group_attributes.index` |

您可以使用 **`resource.as` 方法**重命名所有路由的前缀。在以下示例中，我们将 `group_attributes.index` 路由名称重命名为 `attributes.index`。

```ts
// title: start/routes.ts
router.resource('group-attributes', GroupAttributesController).as('attributes') // 最终名称: attributes.index, attributes.show, ...
```

传递给 `resource.as` 方法的前缀会被转换为下划线命名法。如果需要，您可以关闭此转换，如下所示。

```ts
// title: start/routes.ts
router.resource('group-attributes', GroupAttributesController).as('groupAttributes', false) // 最终名称: groupAttributes.index, ...
```

### 仅注册 API 路由 (Registering API only routes)

创建 API 服务器时，用于创建和更新资源的表单由前端客户端或移动应用程序渲染。因此，为这些端点创建路由是多余的。

您可以使用 **`resource.apiOnly` 方法**来删除 `create` 和 `edit` 路由。结果将只创建**五条路由**。

```ts
// title: start/routes.ts
router.resource('posts', PostsController).apiOnly()
```

### 仅注册特定路由 (Registering only specific routes)

要仅注册特定路由，您可以使用 **`resource.only`** 或 **`resource.except`** 方法。

`resource.only` 方法接受一个操作名称数组，并删除除提及的路由之外的所有其他路由。在以下示例中，将**仅注册** `index`、`store` 和 `destroy` 操作的路由。

```ts
// title: start/routes.ts
router
  .resource('posts', PostsController)
  .only(['index', 'store', 'destroy'])
```

`resource.except` 方法与 `only` 方法相反，它会注册所有路由，**除了**提及的路由。

```ts
// title: start/routes.ts
router
  .resource('posts', PostsController)
  .except(['destroy'])
```

### 重命名资源参数 (Renaming resource params)

`router.resource` 方法生成的路由使用 **`id`** 作为参数名称。例如，`GET /posts/:id` 用于查看单个帖子，`DELETE /post/:id` 用于删除帖子。

您可以使用 **`resource.params` 方法**将参数从 `id` 重命名为其他名称。

```ts
// title: start/routes.ts
router
  .resource('posts', PostsController)
  .params({ posts: 'post' }) // 将 posts 资源的 id 参数重命名为 :post
```

上述更改将生成以下路由（显示部分列表）。

| HTTP 方法 | 路由 | Controller 方法 |
| :--- | :--- | :--- |
| GET | `/posts/:post` | show |
| GET | `/posts/:post/edit` | edit |
| PUT | `/posts/:post` | update |
| DELETE | `/posts/:post` | destroy |

使用嵌套资源时，您也可以重命名参数。

```ts
// title: start/routes.ts
router
  .resource('posts.comments', PostsController)
  .params({
    posts: 'post', // 父资源参数重命名为 :post
    comments: 'comment', // 子资源参数重命名为 :comment
  })
```

### 为资源路由分配中间件 (Assigning middleware to resource routes)

您可以使用 **`resource.use` 方法**为资源注册的路由分配中间件。该方法接受一个**操作名称数组**以及要分配给它们的**中间件**。例如：

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'
import { middleware } from '#start/kernel'

router
  .resource('posts')
  .use(
    ['create', 'store', 'update', 'destroy'], // 要应用中间件的操作
    middleware.auth() // 身份验证中间件
  )
```

您可以使用**通配符 (`*`) 关键字**为**所有路由**分配中间件。

```ts
// title: start/routes.ts
router
  .resource('posts')
  .use('*', middleware.auth()) // 应用到所有资源路由
```

最后，您可以**多次调用 `.use` 方法**来分配多个中间件。例如：

```ts
// title: start/routes.ts
router
  .resource('posts')
  .use(
    ['create', 'store', 'update', 'destroy'],
    middleware.auth()
  )
  .use(
    ['update', 'destroy'],
    middleware.someMiddleware() // 额外的中间件
  )
```