# 中间件 (Middleware)

**中间件 (Middleware)** 是在 HTTP 请求到达路由处理程序之前执行的一系列函数。链中的每个函数都可以**结束请求**或将其**转发给下一个中间件**。

典型的 AdonisJS 应用程序使用中间件进行**解析请求体**、**管理用户会话**、**验证请求身份**、**提供静态资源**等。

您还可以创建**自定义中间件**以在 HTTP 请求期间执行附加任务。

-----

## 中间件栈 (Middleware stacks)

为了让您更好地控制中间件管道的执行，AdonisJS 将中间件栈分为以下三个组。

### 服务器中间件栈 (Server middleware stack)

**服务器中间件**在**每个 HTTP 请求**上运行，即使您尚未为当前请求的 URL 定义任何路由。

它们非常适合为您的应用程序添加不依赖于框架路由系统的附加功能。例如，**静态资源中间件**就是注册为服务器中间件。

您可以使用 `start/kernel.ts` 文件中的 **`server.use` 方法**注册服务器中间件。

```ts
import server from '@adonisjs/core/services/server'

server.use([
  () => import('@adonisjs/static/static_middleware') // 静态资源中间件
])
```

-----

### 路由器中间件栈 (Router middleware stack)

**路由器中间件**也称为**全局中间件 (global middleware)**。它们在**每个具有匹配路由的 HTTP 请求**上执行。

Bodyparser、auth 和 session 中间件都注册在路由器中间件栈下。

您可以使用 `start/kernel.ts` 文件中的 **`router.use` 方法**注册路由器中间件。

```ts
import router from '@adonisjs/core/services/router'

router.use([
  () => import('@adonisjs/core/bodyparser_middleware') // Bodyparser 中间件
])
```

-----

### 命名中间件集合 (Named middleware collection)

**命名中间件**是中间件的集合，**除非明确分配给路由或分组**，否则它们不会执行。

我们建议您创建专用的**中间件类**，将它们存储在命名中间件集合中，然后将它们分配给路由，而不是在路由文件内将中间件定义为内联回调。

您可以使用 `start/kernel.ts` 文件中的 **`router.named` 方法**定义命名中间件。请确保导出命名集合以便能够 [在路由文件内使用](https://www.google.com/search?q=%23assigning-middleware-to-routes-and-route-groups)。

```ts
import router from '@adonisjs/core/services/router'

// 定义命名中间件集合
router.named({
  auth: () => import('#middleware/auth_middleware') // 命名为 'auth'
})
```

-----

## 创建中间件 (Creating middleware)

中间件存储在 `./app/middleware` 目录中，您可以通过运行 `make:middleware` ace 命令创建一个新的中间件文件。

另请参阅：[Make middleware 命令](https://www.google.com/search?q=../references/commands.md%23makemiddleware)

```sh
node ace make:middleware user_location
```

上述命令将在 middleware 目录下创建 `user_location_middleware.ts` 文件。

中间件表示为一个包含 **`handle` 方法**的类。在执行期间，AdonisJS 将自动调用此方法，并将 [HttpContext](https://www.google.com/search?q=../concepts/http_context.md) 作为**第一个参数**传递给它。

```ts
// title: app/middleware/user_location_middleware.ts
import { HttpContext } from '@adonisjs/core/http'
import { NextFn } from '@adonisjs/core/types/http'

export default class UserLocationMiddleware {
  // handle 方法是中间件的入口点
  async handle(ctx: HttpContext, next: NextFn) {
    // ... 逻辑
  }
}
```

在 `handle` 方法中，中间件必须决定是**继续请求**、通过发送响应**结束请求**，还是通过抛出异常**中止请求**。

### 中止请求 (Abort request)

如果中间件**抛出异常**，所有后续的中间件和路由处理程序将**不会执行**，异常将被交给全局异常处理程序。

```ts
import { Exception } from '@adonisjs/core/exceptions'
import { NextFn } from '@adonisjs/core/types/http'

export default class UserLocationMiddleware {
  async handle(ctx: HttpContext, next: NextFn) {
    throw new Exception('Aborting request') // 抛出异常中止
  }
}
```

### 继续请求 (Continue with the request)

您必须调用 **`next` 方法**来继续请求。否则，中间件栈中的其余操作将不会执行。

```ts
export default class UserLocationMiddleware {
  async handle(ctx: HttpContext, next: NextFn) {
    // ... 执行下游 (downstream) 逻辑
    
    // 必须调用 `next` 函数来继续到下一个中间件或路由处理程序
    await next() 

    // ... 执行上游 (upstream) 逻辑
  }
}
```

### 发送响应，不调用 `next` 方法 (Send a response, and do not call the `next` method)

最后，您可以通过**发送响应**来结束请求。在这种情况下，**不要调用 `next` 方法**。

```ts
export default class UserLocationMiddleware {
  async handle(ctx: HttpContext, next: NextFn) {
    // 发送响应 + 不调用 next，请求在此结束
    ctx.response.send('Ending request')
  }
}
```

-----

## 将中间件分配给路由和路由分组 (Assigning middleware to routes and route groups)

命名中间件集合默认是未使用的，您必须**明确地**将它们分配给路由或路由分组。

在以下示例中，我们首先导入 **`middleware` 集合**，然后将 `userLocation` 中间件分配给一条路由。

```ts
import router from '@adonisjs/core/services/router'
import { middleware } from '#start/kernel' // 导入命名中间件集合

router
  .get('posts', () => {})
  .use(middleware.userLocation()) // 使用命名中间件
```

可以作为**数组**应用多个中间件，或**多次调用 `use` 方法**。

```ts
router
  .get('posts', () => {})
  .use([ // 作为数组应用
    middleware.userLocation(),
    middleware.auth()
  ])
```

类似地，您也可以将中间件分配给**路由分组**。分组中间件将自动应用于所有分组路由。

```ts
import router from '@adonisjs/core/services/router'
import { middleware } from '#start/kernel'

router.group(() => {

  router.get('posts', () => {})
  router.get('users', () => {})
  router.get('payments', () => {})

}).use(middleware.userLocation()) // 应用于分组内的所有路由
```

-----

## 中间件参数 (Middleware parameters)

在命名中间件集合下注册的中间件可以接受一个**附加参数**作为 `handle` 方法参数的一部分。例如，`auth` 中间件接受**身份验证守卫 (guard)** 作为配置选项。

```ts
type AuthGuards = 'web' | 'api'

export default class AuthMiddleware {
  // options 参数接收中间件配置
  async handle(ctx, next, options: { guard: AuthGuards }) { 
  }
}
```

将中间件分配给路由时，您可以指定要使用的守卫。

```ts
import router from '@adonisjs/core/services/router'
import { middleware } from '#start/kernel'

router.get('payments', () => {}).use(
  middleware.auth({ guard: 'web' }) // 传递参数
)
```

-----

## 依赖注入 (Dependency injection)

中间件类是使用 [IoC 容器](https://www.google.com/search?q=../concepts/dependency_injection.md) 实例化的；因此，您可以在中间件**构造函数**内进行类型提示依赖项，容器将为您注入它们。

假设您有一个 `GeoIpService` 类，用于从请求 IP 查找用户位置，您可以使用 `@inject` 装饰器将其注入到中间件中。

```ts
// title: app/services/geoip_service.ts
export class GeoIpService {
  async lookup(ipAddress: string) {
    // 查找位置并返回
  }
}
```

```ts
import { inject } from '@adonisjs/core'
import { GeoIpService } from '#services/geoip_service'
import type { HttpContext } from '@adonisjs/core/http'
import type { NextFn } from '@adonisjs/core/types/http'

@inject() // 启用构造函数注入
export default class UserLocationMiddleware {
  // IoC 容器将注入 GeoIpService 实例
  constructor(protected geoIpService: GeoIpService) { 
  }

  async handle(ctx: HttpContext, next: NextFn) {
    const ip = ctx.request.ip()
    // 使用注入的服务
    ctx.location = await this.geoIpService.lookup(ip) 
    await next() // 继续请求
  }
}
```

-----

## 中间件执行流程 (Middleware execution flow)

AdonisJS 的中间件层构建在**责任链 (Chain of Responsibility)**  设计模式之上。一个中间件有两个执行阶段：**下游阶段 (downstream phase)** 和**上游阶段 (upstream phase)**。

  * **下游阶段**：是您在调用 **`next` 方法之前**编写的代码块。在这个阶段，您处理请求。
  * **上游阶段**：是您在调用 **`next` 方法之后**可能编写的代码块。在这个阶段，您可以检查响应或完全更改它。

-----

## 中间件与异常处理 (Middleware and exception handling)

AdonisJS 会自动捕获由中间件管道或路由处理程序抛出的异常，并使用[全局异常处理程序](https://www.google.com/search?q=./exception_handling.md)将其转换为 HTTP 响应。

因此，您**无需**将 `next` 函数调用包装在 `try/catch` 语句中。此外，自动异常处理可确保中间件的**上游逻辑**总是在 `next` 函数调用之后执行。

-----

## 从中间件改变响应 (Mutating response from a middleware)

中间件的**上游阶段**可以改变响应体、标头和状态码。这样做将**丢弃**由路由处理程序或任何其他中间件设置的旧响应。

在改变响应之前，您必须确保您正在处理**正确的响应类型**。以下是 `Response` 类中的响应类型列表。

  * **标准响应 (Standard response)**：指使用 `response.send` 方法发送数据值。其值可能是 `Array`、`Object`、`String`、`Boolean` 或 `Buffer`。
  * **流式响应 (Streaming response)**：指使用 `response.stream` 方法将流管道传输到响应套接字。
  * **文件下载响应 (File download response)**：指使用 `response.download` 方法下载文件。

根据响应类型，您将能够/不能够访问特定的响应属性。

### 处理标准响应 (Dealing with a standard response)

在改变标准响应时，您可以使用 **`response.content` 属性**访问它。请务必首先检查 `content` 是否存在（即 `response.hasContent`）。

```ts
import { HttpContext } from '@adonisjs/core/http'
import { NextFn } from '@adonisjs/core/types/http'

export default class {
  async handle({ response }: HttpContext, next: NextFn) {
    await next() // 执行下游

    // 在上游检查是否有内容
    if (response.hasContent) { 
      console.log(response.content)
      console.log(typeof response.content)
      
      // 改变/发送新的响应
      const newResponse = // ... new content
      response.send(newResponse) 
    }
  }
}
```

### 处理流式响应 (Dealing with a streaming response)

使用 **`response.stream` 方法**设置的响应流**不会立即**管道传输到传出的 HTTP 响应。相反，AdonisJS 会等待路由处理程序和中间件管道完成。

因此，在中间件内部，您可以**用新流替换现有流**或定义**事件处理程序**来监视流。

```ts
import { HttpContext } from '@adonisjs/core/http'
import { NextFn } from '@adonisjs/core/types/http'

export default class {
  async handle({ response }: HttpContext, next: NextFn) {
    await next()
    
    // 在上游检查是否有流
    if (response.hasStream) {
      // 可以在此处替换 response.outgoingStream
      response.outgoingStream.on('data', (chunk) => {
        console.log(chunk)
      })
    }
  }
}
```

### 处理文件下载 (Dealing with file downloads)

使用 **`response.download`** 和 **`response.attachment` 方法**执行的文件下载会**推迟下载过程**，直到路由处理程序和中间件管道完成。

因此，在中间件内部，您可以**替换要下载的文件路径**。

```ts
import { HttpContext } from '@adonisjs/core/http'
import { NextFn } from '@adonisjs/core/types/http'

export default class {
  async handle({ response }: HttpContext, next: NextFn) {
    await next()
    
    // 在上游检查是否有文件流
    if (response.hasFileToStream) {
      console.log(response.fileToStream.generateEtag)
      console.log(response.fileToStream.path)
      // 可以替换 response.fileToStream.path
    }
  }
}
```

-----

## 测试中间件类 (Testing middleware classes)

将中间件创建为类使您能够轻松地**隔离测试**中间件（即对中间件进行单元测试）。测试中间件有几种不同的方法。让我们探索所有可用的选项。

最简单的选项是创建中间件类的一个新实例，并使用 HTTP 上下文和 `next` 回调函数调用 **`handle` 方法**。

```ts
import testUtils from '@adonisjs/core/services/test_utils'
import GeoIpService from '#services/geoip_service'
import UserLocationMiddleware from '#middleware/user_location_middleware'

const middleware = new UserLocationMiddleware(
  new GeoIpService() // 实例化依赖项
)

const ctx = testUtils.createHttpContext() // 创建上下文
await middleware.handle(ctx, () => {
  console.log('Next function invoked') // next 回调函数
})
```

`testUtils` 服务仅在 AdonisJS 应用程序**启动后**可用。但是，如果您正在包内测试中间件，则可以使用 **`HttpContextFactory` 类**创建虚拟 HTTP 上下文实例，而**无需启动应用程序**。

另请参阅：[CORS 中间件测试](https://github.com/adonisjs/cors/blob/main/tests/cors_middleware.spec.ts#L24-L41)以获取实际示例。

```ts
import {
  RequestFactory,
  ResponseFactory,
  HttpContextFactory
} from '@adonisjs/core/factories/http'

const request = new RequestFactory().create()
const response = new ResponseFactory().create()
const ctx = new HttpContextFactory()
  .merge({ request, response }) // 合并请求和响应对象
  .create() // 创建上下文

await middleware.handle(ctx, () => {
  console.log('Next function invoked')
})
```

### 使用服务器管道 (Using server pipeline)

如果您的中间件依赖于其他中间件首先执行，您可以使用 **`server.pipeline` 方法**来组成一个中间件管道。

  * `server.pipeline` 方法接受一个**中间件类数组**。
  * 类实例是使用 IoC 容器创建的。
  * 执行流程与 HTTP 请求期间中间件的原始执行流程相同。

<!-- end list -->

```ts
import testUtils from '@adonisjs/core/services/test_utils'
import server from '@adonisjs/core/services/server'
import UserLocationMiddleware from '#middleware/user_location_middleware'

// 创建包含中间件的管道
const pipeline = server.pipeline([
  UserLocationMiddleware 
])

const ctx = testUtils.createHttpContext()
await pipeline.run(ctx) // 运行管道
```

您可以在调用 `pipeline.run` 方法之前定义 **`finalHandler`** 和 **`errorHandler`** 函数。

  * **`finalHandler`** 在**所有中间件执行完毕**后执行。当任何中间件在没有调用 `next` 方法的情况下结束链时，`finalHandler` **不会执行**。
  * **`errorHandler`** 在**中间件抛出异常**时执行。上游流程将在调用错误处理程序后开始。

<!-- end list -->

```ts
const ctx = testUtils.createHttpContext()

await pipeline
 .finalHandler(() => {
   console.log('all middleware called next')
   console.log('the upstream logic starts from here')
 })
 .errorHandler((error) => {
   console.log('an exception was raised')
   console.log('the upstream logic starts from here')
 })
 .run(ctx)
 
console.log('pipeline executed')
```

`server` 服务在应用程序**启动后**可用。但是，如果您正在创建包，则可以使用 **`ServerFactory`** 创建 Server 类的实例，而**无需启动应用程序**。

```ts
import { ServerFactory } from '@adonisjs/core/factories/http'

const server = new ServerFactory().create()
const pipeline = server.pipeline([
  UserLocationMiddleware
])
```