# HTTP 上下文 (HTTP context)

每次 HTTP 请求都会生成 [HTTP Context 类](https://github.com/adonisjs/http-server/blob/main/src/http_context/main.ts)的一个新实例，并将其传递给路由处理程序、中间件和异常处理程序。

HTTP Context 拥有您可能需要的与 HTTP 请求相关的所有信息。例如：

  * 您可以使用 **[ctx.request](https://www.google.com/search?q=../basics/request.md)** 属性访问请求体、头部和查询参数。
  * 您可以使用 **[ctx.response](https://www.google.com/search?q=../basics/response.md)** 属性响应 HTTP 请求。
  * 使用 **[ctx.auth](https://www.google.com/search?q=../authentication/introduction.md)** 属性访问已登录用户。
  * 使用 **[ctx.bouncer](https://www.google.com/search?q=../security/authorization.md)** 属性授权用户操作。
  * 依此类推。

简而言之，上下文是一个**请求特定的存储**，用于保存正在进行的请求的所有信息。

-----

## 获取 HTTP 上下文 (Getting access to the HTTP context)

HTTP 上下文是通过**引用**传递给路由处理程序、中间件和异常处理程序的，您可以按如下方式访问它。

### 路由处理程序 (Route handler)

[路由处理程序](https://www.google.com/search?q=../basics/routing.md)将 HTTP 上下文作为**第一个参数**接收。

```ts
import router from '@adonisjs/core/services/router'

router.get('/', (ctx) => {
  console.log(ctx.inspect())
})
```

```ts
// title: 解构属性 (Destructure properties)
import router from '@adonisjs/core/services/router'

router.get('/', ({ request, response }) => {
  console.log(request.url())
  console.log(request.headers())
  console.log(request.qs())
  console.log(request.body())
  
  response.send('hello world')
  response.send({ hello: 'world' })
})
```

### 控制器方法 (Controller method)

[控制器方法](https://www.google.com/search?q=../basics/controllers.md)（类似于路由处理程序）将 HTTP 上下文作为**第一个参数**接收。

```ts
import { HttpContext } from '@adonisjs/core/http'

export default class HomeController {
  async index({ request, response }: HttpContext) {
    // ...
  }
}
```

### 中间件类 (Middleware class)

[中间件类](https://www.google.com/search?q=../basics/middleware.md)的 `handle` 方法将 HTTP 上下文作为**第一个参数**接收。

```ts
import { HttpContext } from '@adonisjs/core/http'

export default class AuthMiddleware {
  async handle({ request, response }: HttpContext) {
    // ...
  }
}
```

### 异常处理程序类 (Exception handler class)

[全局异常处理程序](https://www.google.com/search?q=../basics/exception_handling.md)类的 `handle` 和 `report` 方法将 HTTP 上下文作为**第二个参数**接收。第一个参数是 `error` 属性。

```ts
import {
  HttpContext,
  HttpExceptionHandler
} from '@adonisjs/core/http'

export default class ExceptionHandler extends HttpExceptionHandler {
  async handle(error: unknown, ctx: HttpContext) {
    return super.handle(error, ctx)
  }

  async report(error: unknown, ctx: HttpContext) {
    return super.report(error, ctx)
  }
}
```

-----

## 使用依赖注入注入 HTTP 上下文 (Injecting HTTP Context using Dependency Injection)

如果您在整个应用程序中使用了**依赖注入 (DI)**，您可以通过**类型提示** `HttpContext` 类来将 HTTP 上下文注入到类或方法中。

:::warning

请确保 `#middleware/container_bindings_middleware` 中间件已注册在 `start/kernel.ts` 文件中。此中间件是必需的，以便从容器中解析请求特定的值（即 HttpContext 类）。

:::

另请参阅：[IoC 容器指南](https://www.google.com/search?q=../concepts/dependency_injection.md)

```ts
// title: app/services/user_service.ts
import { inject } from '@adonisjs/core'
import { HttpContext } from '@adonisjs/core/http'

@inject()
export default class UserService {
  // 注入 HttpContext 实例
  constructor(protected ctx: HttpContext) {} 
  
  all() {
    // method implementation
  }
}
```

为了让自动依赖解析工作，您必须在控制器中注入 `UserService`。请记住，控制器方法的第一个参数将始终是上下文，其余的将使用 IoC 容器注入。

```ts
import { inject } from '@adonisjs/core'
import { HttpContext } from '@adonisjs/core/http'
import UserService from '#services/user_service'

export default class UsersController {
  @inject()
  // 第一个参数是 HttpContext，第二个参数是注入的 UserService
  index(ctx: HttpContext, userService: UserService) { 
    return userService.all()
  }
}
```

就是这样！`UserService` 现在将自动接收正在进行的 HTTP 请求的实例。您也可以对嵌套依赖项重复相同的过程。

-----

## 从应用程序内部任何地方访问 HTTP 上下文 (Accessing HTTP context from anywhere inside your application)

依赖注入是一种将 HTTP 上下文作为类构造函数或方法依赖项接受，然后依赖容器为您解析它的方式。

然而，重构您的应用程序并在所有地方使用依赖注入并不是一个硬性要求。您还可以使用 Node.js 提供的**异步本地存储 (Async local storage)** 从应用程序内部的任何地方访问 HTTP 上下文。

我们有一个[专门的指南](https://www.google.com/search?q=./async_local_storage.md)介绍了异步本地存储的工作原理以及 AdonisJS 如何使用它来提供对 HTTP 上下文的全局访问。

在以下示例中，`UserService` 类使用 `HttpContext.getOrFail` 方法来获取正在进行的请求的 HTTP 上下文实例。

```ts
// title: app/services/user_service.ts
import { HttpContext } from '@adonisjs/core/http'

export default class UserService {
  all() {
    // 从异步本地存储中获取上下文
    const ctx = HttpContext.getOrFail() 
    console.log(ctx.request.url())
  }
}
```

以下代码块展示了 `UserService` 类在 `UsersController` 中的用法。

```ts
import { HttpContext } from '@adonisjs/core/http'
import UserService from '#services/user_service'

export default class UsersController {
  index(ctx: HttpContext) {
    // 无需注入，直接实例化服务
    const userService = new UserService() 
    return userService.all()
  }
}
```

-----

## HTTP 上下文属性 (HTTP Context properties)

以下是您可以通过 HTTP 上下文访问的属性列表。当您安装新的包时，它们可能会向上下文添加额外的属性。

\<dl\>
\<dt\>

ctx.request

\</dt\>

\<dd\>

[HTTP Request 类](https://www.google.com/search?q=../basics/request.md)实例的引用。

\</dd\>

\<dt\>

ctx.response

\</dt\>

\<dd\>

[HTTP Response 类](https://www.google.com/search?q=../basics/response.md)实例的引用。

\</dd\>

\<dt\>

ctx.logger

\</dt\>

\<dd\>

为给定 HTTP 请求创建的 [logger](https://www.google.com/search?q=../digging_deeper/logger.md) 实例的引用。

\</dd\>

\<dt\>

ctx.route

\</dt\>

\<dd\>

当前 HTTP 请求匹配的路由。`route` 属性是 [StoreRouteNode](https://github.com/adonisjs/http-server/blob/main/src/types/route.ts#L69) 类型的一个对象。

\</dd\>

\<dt\>

ctx.params

\</dt\>

\<dd\>

一个路由参数 (route params) 对象。

\</dd\>

\<dt\>

ctx.subdomains

\</dt\>

\<dd\>

一个路由子域名 (route subdomains) 对象。仅当路由是动态子域名的一部分时存在。

\</dd\>

\<dt\>

ctx.session

\</dt\>

\<dd\>

为当前 HTTP 请求创建的 [Session](https://www.google.com/search?q=../basics/session.md) 实例的引用。

\</dd\>

\<dt\>

ctx.auth

\</dt\>

\<dd\>

[Authenticator 类](https://github.com/adonisjs/auth/blob/main/src/authenticator.ts)实例的引用。了解更多关于[认证](https://www.google.com/search?q=../authentication/introduction.md)的信息。

\</dd\>

\<dt\>

ctx.view

\</dt\>

\<dd\>

Edge 渲染器实例的引用。在 [视图和模板指南](https://www.google.com/search?q=../views-and-templates/introduction.md%23using-edge) 中了解更多关于 Edge 的信息。

\</dd\>

\<dt\>

ctx.ally

\</dt\>

\<dd\>

[Ally Manager 类](https://github.com/adonisjs/ally/blob/main/src/ally_manager.ts)实例的引用，用于在应用程序中实现社交登录。了解更多关于 [Ally](https://www.google.com/search?q=../authentication/social_authentication.md) 的信息。

\</dd\>

\<dt\>

ctx.bouncer

\</dt\>

\<dd\>

[Bouncer 类](https://github.com/adonisjs/bouncer/blob/main/src/bouncer.ts)实例的引用。了解更多关于[授权](https://www.google.com/search?q=../security/authorization.md)的信息。

\</dd\>

\<dt\>

ctx.i18n

\</dt\>

\<dd\>

[I18n 类](https://github.com/adonisjs/i18n/blob/main/src/i18n.ts)实例的引用。在[国际化](https://www.google.com/search?q=../digging_deeper/i18n.md)指南中了解更多关于 `i18n` 的信息。

\</dd\>

\</dl\>

-----

## 扩展 HTTP 上下文 (Extending HTTP context)

您可以使用**宏 (macros)** 或 **getters** 向 HTTP context 类添加自定义属性。如果您对宏的概念不熟悉，请务必先阅读 [扩展 AdonisJS 指南](https://www.google.com/search?q=./extending_the_framework.md)。

```ts
import { HttpContext } from '@adonisjs/core/http'

HttpContext.macro('aMethod', function (this: HttpContext) {
  return value
})

HttpContext.getter('aProperty', function (this: HttpContext) {
  return value
})
```

由于宏和 getter 是在运行时添加的，您必须使用**模块增强 (module augmentation)** 来通知 TypeScript 它们的类型。

```ts
import { HttpContext } from '@adonisjs/core/http'

// insert-start
declare module '@adonisjs/core/http' {
  export interface HttpContext {
    aMethod: () => ValueType
    aProperty: ValueType
  }
}
// insert-end

HttpContext.macro('aMethod', function (this: HttpContext) {
  return value
})

HttpContext.getter('aProperty', function (this: HttpContext) {
  return value
})
```

-----

## 在测试期间创建模拟上下文 (Creating dummy context during tests)

您可以使用 `testUtils` 服务在测试期间创建**模拟 (dummy) HTTP 上下文**。

该上下文实例未附加到任何路由；因此，`ctx.route` 和 `ctx.params` 的值将是 `undefined`。但是，如果被测试的代码需要，您可以手动分配这些属性。

```ts
import testUtils from '@adonisjs/core/services/test_utils'

const ctx = testUtils.createHttpContext()
```

默认情况下，`createHttpContext` 方法对 `req` 和 `res` 对象使用虚假值。但是，您可以为这些属性定义自定义值，如以下示例所示。

```ts
import { createServer } from 'node:http'
import testUtils from '@adonisjs/core/services/test_utils'

createServer((req, res) => {
  const ctx = testUtils.createHttpContext({
    // highlight-start
    req,
    res
    // highlight-end
  })
})
```

### 使用 HttpContext 工厂 (Using the HttpContext factory)

`testUtils` 服务仅在 AdonisJS 应用程序内部可用；因此，如果您正在构建一个包并且需要访问一个虚假的 HTTP 上下文，您可以使用 **[HttpContextFactory](https://github.com/adonisjs/http-server/blob/main/factories/http_context.ts#L30)** 类。

```ts
import { HttpContextFactory } from '@adonisjs/core/factories/http'
const ctx = new HttpContextFactory().create()
```