# 文件上传 (File uploads)

AdonisJS 对使用 **`multipart/form-data`** 内容类型发送的**用户上传文件**提供了一流的支持。文件通过 [bodyparser 中间件](https://www.google.com/search?q=../basics/body_parser.md%23multipart-parser) 进行**自动处理**，并保存在您操作系统的 **`tmp` 目录**中。

随后，在您的控制器内部，您可以访问这些文件，对它们进行验证，并将它们移动到**永久存储位置**或 **S3** 等云存储服务。

-----

## 访问用户上传的文件 (Access user-uploaded files)

您可以使用 **`request.file(fieldName)` 方法**访问单个用户上传的文件。该方法接受**字段名称**并返回 **`MultipartFile`** 的实例。

```ts
import { HttpContext } from '@adonisjs/core/http'

export default class UserAvatarsController {
  update({ request }: HttpContext) {
    // 获取名为 'avatar' 的上传文件
    const avatar = request.file('avatar') 
    console.log(avatar)
  }
}
```

如果一个输入字段用于上传**多个文件**，您可以使用 **`request.files(fieldName)` 方法**访问它们。该方法接受字段名称并返回一个 `MultipartFile` 实例的**数组**。

```ts
import { HttpContext } from '@adonisjs/core/http'

export default class InvoicesController {
  update({ request }: HttpContext) {
    // 获取名为 'documents' 的所有上传文件
    const invoiceDocuments = request.files('documents') 
    
    for (let document of invoiceDocuments) {
      console.log(document)
    }
  }
}
```

-----

## 手动验证文件 (Manually validating files)

您可以使用 [验证器](https://www.google.com/search?q=%23using-validator) 验证文件，或者通过 **`request.file` 方法**定义验证规则。

在以下示例中，我们将通过 `request.file` 方法**内联**定义验证规则，并使用 **`file.errors` 属性**访问验证错误。

```ts
const avatar = request.file('avatar', {
  size: '2mb', // 最大 2MB
  extnames: ['jpg', 'png', 'jpeg'] // 允许的扩展名
})

if (!avatar.isValid) {
  // 如果验证失败，则返回 400 错误和错误信息
  return response.badRequest({
    errors: avatar.errors
  })
}
```

处理文件数组时，您可以遍历文件并检查**一个或多个文件**是否验证失败。

提供给 `request.files` 方法的验证选项将**应用于所有文件**。在以下示例中，我们要求每个文件都小于 `2mb`，并且必须具有允许的文件扩展名之一。

```ts
const invoiceDocuments = request.files('documents', {
  size: '2mb',
  extnames: ['jpg', 'png', 'pdf']
})

/**
 * 创建一个无效文档的集合
 */
let invalidDocuments = invoiceDocuments.filter((document) => {
  return !document.isValid // 检查文件是否有效
})

if (invalidDocuments.length) {
  /**
   * 返回包含文件名和对应错误的 400 响应
   */
  return response.badRequest({
    errors: invalidDocuments.map((document) => {
      return {
        name: document.clientName, // 原始文件名
        errors: document.errors, // 错误数组
      }
    })
  })
}
```

-----

## 使用验证器验证文件 (Using validator to validate files)

除了手动验证文件（如上一节所示），您可以使用 [**验证器**](https://www.google.com/search?q=./validation.md) 作为**验证管道**的一部分来验证文件。使用验证器时，您**不必**手动检查错误；验证管道会处理一切。

```ts
// app/validators/user_validator.ts
import vine from '@vinejs/vine'

export const updateAvatarValidator = vine.compile(
  vine.object({
    // 使用 vine.file() 模式验证单个文件
    avatar: vine.file({ 
      size: '2mb',
      extnames: ['jpg', 'png', 'pdf']
    })
  })
)
```

```ts
import { HttpContext } from '@adonisjs/core/http'
import { updateAvatarValidator } from '#validators/user_validator'

export default class UserAvatarsController {
  async update({ request }: HttpContext) {
    // 验证失败会自动抛出异常，并由异常处理程序处理
    const { avatar } = await request.validateUsing(
      updateAvatarValidator
    )
    // 此时 avatar 已经是已验证且类型安全的 MultipartFile 实例
  }
}
```

可以使用 **`vine.array` 类型**来验证文件数组。例如：

```ts
import vine from '@vinejs/vine'

export const createInvoiceValidator = vine.compile(
  vine.object({
    documents: vine.array( // 验证数组
      vine.file({ // 数组中的每一项都是一个文件
        size: '2mb',
        extnames: ['jpg', 'png', 'pdf']
      })
    )
  })
)
```

-----

## 将文件移动到永久位置 (Moving files to a persistent location)

默认情况下，用户上传的文件保存在您操作系统的 **`tmp` 目录**中，并且可能会在计算机清理 `tmp` 目录时被删除。

因此，建议将文件存储在**永久位置**。您可以使用 **`file.move(directoryPath, options)`** 将文件移动到同一文件系统中的目录。该方法接受一个**绝对路径**到要移动到的目录。

```ts
import app from '@adonisjs/core/services/app'

const avatar = request.file('avatar', {
  size: '2mb',
  extnames: ['jpg', 'png', 'jpeg']
})

// 确保文件有效
if (!avatar.isValid) { 
  // ... handle errors
}

// 将 avatar 移动到应用的 "storage/uploads" 目录
await avatar.move(app.makePath('storage/uploads')) 
```

建议为移动后的文件提供一个**唯一随机名称**。为此，您可以使用 **`cuid` 辅助函数**。

```ts
import { cuid } from '@adonisjs/core/helpers'
import app from '@adonisjs/core/services/app'

await avatar.move(app.makePath('storage/uploads'), {
  // 使用 cuid() 生成唯一名称，并保留原始扩展名
  name: `${cuid()}.${avatar.extname}` 
})
```

文件移动后，您可以将其名称存储在数据库中以供将来引用。

```ts
await avatar.move(app.makePath('uploads'))

/**
 * 示例代码，将文件名保存为用户模型的 avatar 属性，
 * 并将其持久化到数据库。
 */
auth.user!.avatar = avatar.fileName! // 访问 move 后的文件名
await auth.user.save()
```

### 文件属性 (File properties)

以下是您可以在 `MultipartFile` 实例上访问的属性列表。

| 属性 | 描述 |
| :--- | :--- |
| `fieldName` | HTML 输入字段的名称。 |
| `clientName` | 用户计算机上的文件名。 |
| `size` | 文件大小（字节）。 |
| `extname` | 文件扩展名。 |
| `errors` | 与给定文件关联的错误数组。 |
| `type` | 文件的 [mime type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)（例如 `image`）。 |
| `subtype` | 文件的 [mime subtype](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)（例如 `jpeg`）。 |
| `filePath` | `move` 操作后文件的**绝对路径**。 |
| `fileName` | `move` 操作后的**文件名**。 |
| `tmpPath` | 文件在 `tmp` 目录中的绝对路径。 |
| `meta` | 与文件关联的键值对元数据。对象默认为空。 |
| `validated` | 布尔值，表示文件是否已验证。 |
| `isValid` | 布尔值，表示文件是否通过了验证规则。 |
| `hasErrors` | 布尔值，表示给定文件是否关联了一个或多个错误。 |

-----

## 提供文件服务 (Serving files)

如果您将用户上传的文件持久化到与应用程序代码**相同的**文件系统中，您可以通过创建路由并使用 [`response.download`](https://www.google.com/search?q=./response.md%23downloading-files) 方法来提供文件服务。

```ts
import { sep, normalize } from 'node:path'
import app from '@adonisjs/core/services/app'
import router from '@adonisjs/core/services/router'

const PATH_TRAVERSAL_REGEX = /(?:^|[\\/])\.\.(?:[\\/]|$)/

// 匹配 /uploads/ 后面的所有路径
router.get('/uploads/*', ({ request, response }) => { 
  // 获取通配符参数，并用路径分隔符连接成字符串
  const filePath = request.param('*').join(sep) 
  // 规范化路径，处理 /../ 等
  const normalizedPath = normalize(filePath) 
  
  // 使用正则表达式防止路径遍历攻击
  if (PATH_TRAVERSAL_REGEX.test(normalizedPath)) { 
    return response.badRequest('Malformed path')
  }

  // 构造文件在服务器上的绝对路径
  const absolutePath = app.makePath('uploads', normalizedPath) 
  // 使用 response.download 提供文件服务
  return response.download(absolutePath) 
})
```

  - 我们使用 [通配符路由参数](https://www.google.com/search?q=./routing.md%23wildcard-params) 获取文件路径，并将其数组转换为字符串。
  - 接下来，我们使用 Node.js 的 `path` 模块**规范化**路径。
  - 使用 `PATH_TRAVERSAL_REGEX` 保护此路由免受 [路径遍历攻击](https://owasp.org/www-community/attacks/Path_Traversal)。
  - 最后，我们将 `normalizedPath` 转换为 `uploads` 目录内的绝对路径，并使用 `response.download` 方法提供文件服务。

-----

## 使用 Drive 上传和提供文件服务 (Using Drive to upload and serve files)

**Drive** 是 AdonisJS 核心团队创建的**文件系统抽象**。您可以使用 Drive 来管理用户上传的文件，并将其存储在本地文件系统或移动到 **S3** 或 **GCS** 等云存储服务。

我们建议使用 **Drive** 而不是手动上传和提供文件服务。Drive 处理了许多安全问题（如路径遍历），并在多个存储提供程序之间提供**统一的 API**。

[了解有关 Drive 的更多信息](https://www.google.com/search?q=../digging_deeper/drive.md)

-----

## 高级 - 自处理多部分流 (Advanced - Self-processing multipart stream)

您可以关闭多部分请求的**自动处理**，并为高级用例**自处理流**。打开 `config/bodyparser.ts` 文件并更改以下选项之一来禁用自动处理。

```ts
{
  multipart: {
    /**
     * 设置为 false，如果您想手动为所有 HTTP 请求自处理
     * 多部分流。
     */
    autoProcess: false
  }
}
```

```ts
{
  multipart: {
    /**
     * 定义一个路由模式数组，您希望为这些路由
     * 手动自处理多部分流。
     */
    processManually: ['/assets']
  }
}
```

禁用自动处理后，您可以使用 **`request.multipart` 对象**来处理单个文件。

在以下示例中，我们使用 Node.js 的 `stream.pipeline` 方法来处理多部分的**可读流**，并将其写入磁盘上的文件。但是，您可以将此文件流式传输到像 `s3` 这样的**外部服务**。

```ts
import { createWriteStream } from 'node:fs'
import app from '@adonisjs/core/services/app'
import { pipeline } from 'node:stream/promises'
import { HttpContext } from '@adonisjs/core/http'

export default class AssetsController {
  async store({ request }: HttpContext) {
    /**
     * 步骤 1: 定义文件监听器
     */
    request.multipart.onFile('*', {}, async (part, reporter) => {
      part.pause() // 暂停流，以便您能处理
      part.on('data', reporter) // 将 reporter 绑定到 data 事件以启用验证和进度跟踪

      const filePath = app.makePath(part.file.clientName)
      // 使用 pipeline 将文件流写入磁盘
      await pipeline(part, createWriteStream(filePath)) 
      return { filePath } // 返回的数据将合并到文件对象中
    })

    /**
     * 步骤 2: 处理流
     */
    await request.multipart.process()

    /**
     * 步骤 3: 访问已处理的文件
     */
    return request.allFiles() // 返回所有已处理的文件
  }
}
```

  - **`multipart.onFile(fieldName, options, callback)` 方法**接受您要处理文件的输入字段名称。您可以使用通配符 `*` 来处理所有文件。

  - `onFile` 监听器接收 `part`（可读流）作为第一个参数，以及一个 `reporter` 函数作为第二个参数。

  - `reporter` 函数用于**跟踪流进度**，以便 AdonisJS 可以在流处理完成后向您提供对已处理字节、文件扩展名和其他元数据的访问。

  - 最后，您可以从 `onFile` 监听器返回一个属性对象，它们将与您使用 `request.file` 或 `request.allFiles()` 方法访问的文件对象**合并**。

### 错误处理 (Error handling)

您必须监听 `part` 对象上的 **`error` 事件**并手动处理错误。通常，流读取器（可写流）会在内部监听此事件并中止写入操作。

### 验证流部分 (Validating stream parts)

即使您手动处理多部分流，AdonisJS 也允许您**验证流部分**（即文件）。如果发生错误，**`error` 事件**将在 `part` 对象上触发。

`multipart.onFile` 方法接受**验证选项**作为**第二个参数**。另外，请确保监听 **`data` 事件**并将 **`reporter` 方法**绑定到它。否则，不会进行任何验证。

```ts
request.multipart.onFile('*', {
  size: '2mb',
  extnames: ['jpg', 'png', 'jpeg']
}, async (part, reporter) => {
  /**
   * 需要以下两行来执行流验证
   */
  part.pause()
  part.on('data', reporter) // 必须绑定 reporter 才能进行验证
})
```