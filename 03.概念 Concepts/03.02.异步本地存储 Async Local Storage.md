# 异步本地存储 (Async local storage)

根据 [Node.js 官方文档](https://nodejs.org/docs/latest-v21.x/api/async_context.html#class-asynclocalstorage)：“AsyncLocalStorage 用于在回调和 Promise 链中创建异步状态。**它允许在 Web 请求的生命周期或任何其他异步持续时间内存储数据。它类似于其他语言中的线程本地存储 (thread-local storage)。**”

为了进一步简化解释，AsyncLocalStorage 允许您在执行异步函数时存储一个状态，并使该状态在该函数内的所有代码路径中均可用。

## 基本示例 (Basic example)

让我们来看看实际操作。首先，我们将创建一个新的 Node.js 项目（没有任何依赖项），并使用 `AsyncLocalStorage` 在模块之间共享状态，而无需通过引用传递它。

:::note

您可以在 [als-basic-example](https://github.com/thetutlage/als-basic-example) GitHub 仓库中找到此示例的最终代码。

:::

### 第 1 步：创建一个新项目

```sh
npm init --yes
```

打开 `package.json` 文件并将模块系统设置为 ESM。

```json
{
  "type": "module"
}
```

### 第 2 步：创建 `AsyncLocalStorage` 实例

创建一个名为 `storage.js` 的文件，该文件创建并导出 `AsyncLocalStorage` 的实例。

```ts
// title: storage.js
import { AsyncLocalStorage } from 'async_hooks'
export const storage = new AsyncLocalStorage()
```

### 第 3 步：在 `storage.run` 内部执行代码

创建一个名为 `main.js` 的入口文件。在此文件内，导入在 `./storage.js` 文件中创建的 `AsyncLocalStorage` 实例。

`storage.run` 方法接受我们想要共享的状态作为第一个参数，并接受一个回调函数作为第二个参数。此回调内的所有代码路径（包括导入的模块）都将有权访问相同的状态。

```ts
// title: main.js
import { storage } from './storage.js'
import UserService from './user_service.js'
import { setTimeout } from 'node:timers/promises'

async function run(user) {
  const state = { user }

  return storage.run(state, async () => {
    await setTimeout(100)
    const userService = new UserService()
    await userService.get()
  })
}
```

为了演示，我们将执行 `run` 方法三次而不等待 (await) 它。将以下代码粘贴到 `main.js` 文件的末尾。

```ts
// title: main.js
run({ id: 1 })
run({ id: 2 })
run({ id: 3 })
```

### 第 4 步：从 `user_service` 模块访问状态

最后，让我们在 `user_service` 模块中导入 storage 实例并访问当前状态。

```ts
// title: user_service.js
import { storage } from './storage.js'

export class UserService {
  async get() {
    const state = storage.getStore()
    console.log(`The user id is ${state.user.id}`)
  }
}
```

### 第 5 步：执行 `main.js` 文件

让我们运行 `main.js` 文件，看看 `UserService` 是否可以访问该状态。

```sh
node main.js
```

## 为什么需要异步本地存储？ (What is the need for Async local storage?)

与 PHP 等其他语言不同，Node.js 不是一种线程语言。在 PHP 中，每个 HTTP 请求都会创建一个新线程，并且每个线程都有自己的内存。这允许您将状态存储在全局内存中，并在代码库中的任何位置访问它。

在 Node.js 中，您无法在 HTTP 请求之间拥有隔离的全局状态，因为 Node.js 在单线程上运行并具有共享内存。因此，所有 Node.js 应用程序都通过将数据作为参数传递来共享数据。

通过引用传递数据在技术上没有缺点。但是，它确实使代码变得冗长，特别是当您配置 APM 工具并且必须手动向它们提供请求数据时。

## 用法 (Usage)

AdonisJS 在 HTTP 请求期间使用 `AsyncLocalStorage` 并共享 [HTTP 上下文 (HTTP context)](https://www.google.com/search?q=./http_context.md) 作为状态。因此，您可以在应用程序中全局访问 HTTP 上下文。

首先，您必须在 `config/app.ts` 文件中启用 `useAsyncLocalStorage` 标志。

```ts
// title: config/app.ts
export const http = defineConfig({
  useAsyncLocalStorage: true,
})
```

启用后，您可以使用 `HttpContext.get` 或 `HttpContext.getOrFail` 方法获取当前正在进行的请求的 HTTP 上下文实例。

在以下示例中，我们在 Lucid 模型中获取上下文。

```ts
import { HttpContext } from '@adonisjs/core/http'
import { BaseModel } from '@adonisjs/lucid'

export default class Post extends BaseModel {
  get isLiked() {
    const ctx = HttpContext.getOrFail()
    const authUserId = ctx.auth.user.id
    
    return !!this.likes.find((like) => {
      return like.userId === authUserId
    })
  }
}
```

## 注意事项 (Caveats)

如果 ALS 能让您的代码更直观，并且您更喜欢全局访问而不是通过引用传递 HTTP 上下文，那么您可以使用 ALS。

但是，请注意以下情况，这些情况很容易导致内存泄漏或程序行为不稳定。

### 顶层访问 (Top-level access)

不要在任何模块的顶层访问 ALS，因为 Node.js 中的模块是会被缓存的。

:::caption{for="error"}
**错误用法**  
在顶层将 `HttpContext.getOrFail()` 方法的结果赋值给变量，将保留对首次导入该模块的请求的引用。
:::

```ts
import { HttpContext } from '@adonisjs/core/http'
const ctx = HttpContext.getOrFail()

export default class UsersController {
  async index() {
    ctx.request
  }
}
```

:::caption[]{for="success"}
**正确用法**  
相反，您应该将 `getOrFail` 方法调用移至 `index` 方法内部。
:::

```ts
import { HttpContext } from '@adonisjs/core/http'

export default class UsersController {
  async index() {
    const ctx = HttpContext.getOrFail()
  }
}
```

### 在静态属性中 (Inside static properties)

任何类的静态属性（不是方法）都会在模块导入后立即求值；因此，您不应该在静态属性中访问 HTTP 上下文。

:::caption{for="error"}
**错误用法**
:::

```ts
import { HttpContext } from '@adonisjs/core/http'
import { BaseModel } from '@adonisjs/lucid'

export default class User extends BaseModel {
  static connection = HttpContext.getOrFail().tenant.name
}
```

:::caption[]{for="success"}
**正确用法**  
相反，您应该将 `HttpContext.get` 调用移至方法内部，或将属性转换为 getter。
:::

```ts
import { HttpContext } from '@adonisjs/core/http'
import { BaseModel } from '@adonisjs/lucid'

export default class User extends BaseModel {
  static query() {
    const ctx = HttpContext.getOrFail()
    return super.query({ connection: tenant.connection })
  }
}
```

### 事件处理程序 (Event handlers)

事件处理程序是在 HTTP 请求完成后执行的。因此，您应该避免尝试在其中访问 HTTP 上下文。

```ts
import emitter from '@adonisjs/core/services/emitter'

export default class UsersController {
  async index() {
    const user = await User.create({})
    // 注意：此处 emitter 即为“事件触发器”
    emitter.emit('new:user', user)
  }
}
```

:::caption[]{for="error"}
**避免在事件监听器中使用**
:::

```ts
import { HttpContext } from '@adonisjs/core/http'
import emitter from '@adonisjs/core/services/emitter'

emitter.on('new:user', () => {
  const ctx = HttpContext.getOrFail()
})
```