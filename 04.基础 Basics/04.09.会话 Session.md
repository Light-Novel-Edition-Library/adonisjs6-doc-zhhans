# 会话 (Session)

您可以使用 **`@adonisjs/session` 包**在您的 AdonisJS 应用程序中管理用户会话。`session` 包提供了一个**统一的 API**，用于跨不同的**存储提供程序**存储会话数据。

-----

## 内置存储 (Bundled Stores)

**以下是捆绑的存储列表：**

  * **`cookie`**：会话数据存储在**加密的 Cookie** 中。由于数据存储在客户端，`cookie` 存储非常适用于**多服务器部署**。
  * **`file`**：会话数据保存在服务器上的**文件中**。`file` 存储只有在您使用负载均衡器实现**粘性会话**时才能扩展到多服务器部署。
  * **`redis`**：会话数据存储在 **Redis 数据库**中。`redis` 存储推荐用于具有**大量会话数据**且可以扩展到多服务器部署的应用程序。
  * **`dynamodb`**：会话数据存储在 **Amazon DynamoDB 表**中。`DynamoDB` 存储适用于需要**高度可扩展和分布式**会话存储的应用程序，尤其是在基础设施基于 AWS 时。
  * **`memory`**：会话数据存储在**全局内存存储**中。`memory` 存储在**测试**期间使用。

除了内置的后端存储，您还可以创建和 [注册自定义会话存储](https://www.google.com/search?q=%23creating-a-custom-session-store)。

-----

## 安装 (Installation)

使用以下命令安装和配置该包：

```sh
node ace add @adonisjs/session
```

:::disclosure{title="查看 add 命令执行的步骤"}

1.  使用检测到的包管理器安装 `@adonisjs/session` 包。
2.  在 `adonisrc.ts` 文件中注册以下服务提供程序。
    ```ts
    {
      providers: [
        // ...其他提供程序
        () => import('@adonisjs/session/session_provider')
      ]
    }
    ```
3.  创建 `config/session.ts` 文件。
4.  定义以下环境变量及其验证。
    ```dotenv
    SESSION_DRIVER=cookie
    ```
5.  在 `start/kernel.ts` 文件中注册以下中间件。
    ```ts
    router.use([
      () => import('@adonisjs/session/session_middleware')
    ])
    ```

:::

-----

## 配置 (Configuration)

会话包的配置存储在 **`config/session.ts` 文件**中。

另请参阅：[Session config stub](https://github.com/adonisjs/session/blob/main/stubs/config/session.stub)

```ts
import env from '#start/env'
import app from '@adonisjs/core/services/app'
import { defineConfig, stores } from '@adonisjs/session'

export default defineConfig({
  age: '2h', // 会话数据的有效期
  enabled: true, // 是否启用会话中间件
  cookieName: 'adonis-session', // 存储会话 ID 的 Cookie 名称
  clearWithBrowser: false, // 浏览器关闭时是否清除会话 ID Cookie

  cookie: { // 会话 ID Cookie 的属性
    path: '/',
    httpOnly: true,
    secure: app.inProduction,
    sameSite: 'lax',
  },

  store: env.get('SESSION_DRIVER'), // 使用的存储驱动
  stores: { // 后端存储配置对象
    cookie: stores.cookie(),
  }
})
```

\<dl\>

\<dt\>

`enabled`

\</dt\>

\<dd\>

临时启用或禁用中间件，而无需将其从中间件栈中移除。

\</dd\>

\<dt\>

`cookieName`

\</dt\>

\<dd\>

用于存储**会话 ID** 的 Cookie 名称。您可以随意重命名。

\</dd\>

\<dt\>

`clearWithBrowser`

\</dt\>

\<dd\>

设置为 `true` 时，在用户关闭浏览器窗口后，将移除会话 ID Cookie。此 Cookie 在技术上称为 [会话 Cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#define_the_lifetime_of_a_cookie)。

\</dd\>

\<dt\>

`age`

\</dt\>

\<dd\>

`age` 属性控制**没有用户活动时**会话数据的有效期。超过给定持续时间后，会话数据被视为**已过期**。

\</dd\>

\<dt\>

`cookie`

\</dt\>

\<dd\>

控制会话 ID Cookie 的属性。另请参阅 [Cookie 配置](https://www.google.com/search?q=./cookies.md%23configuration)。

\</dd\>

\<dt\>

`store`

\</dt\>

\<dd\>

定义您想要用于存储会话数据的存储驱动。它可以是固定值或从环境变量中读取。

\</dd\>

\<dt\>

`stores`

\</dt\>

\<dd\>

`stores` 对象用于配置**一个或多个**后端存储。

大多数应用程序将使用单个存储。但是，您可以配置多个存储，并根据应用程序运行的环境在它们之间切换。

\</dd\>

\</dl\>

-----

### 存储配置 (Stores configuration)

以下是 `@adonisjs/session` 包捆绑的后端存储列表：

```ts
import app from '@adonisjs/core/services/app'
import { defineConfig, stores } from '@adonisjs/session'

export default defineConfig({
  store: env.get('SESSION_DRIVER'),

  stores: {
    cookie: stores.cookie(),

    file: stores.file({
      location: app.tmpPath('sessions') // 文件存储位置
    }),

    redis: stores.redis({
      connection: 'main' // Redis 连接名称
    }),

    dynamodb: stores.dynamodb({
      clientConfig: {} // DynamoDB 客户端配置
    }),
  }
})
```

\<dl\>

\<dt\>

`stores.cookie`

\</dt\>

\<dd\>

`cookie` 存储将会话数据**加密**后存储在 Cookie 中。

\</dd\>

\<dt\>

`stores.file`

\</dt\>

\<dd\>

定义 `file` 存储的配置。该方法接受用于存储会话文件的 `location` 路径。

\</dd\>

\<dt\>

`stores.redis`

\</dt\>

\<dd\>

定义 `redis` 存储的配置。该方法接受用于存储会话数据的 **`connection` 名称**。

在使用 `redis` 存储之前，请确保先安装和配置 [@adonisjs/redis](https://www.google.com/search?q=../database/redis.md) 包。

\</dd\>

\<dt\>

`stores.dynamodb`

\</dt\>

\<dd\>

定义 `dynamodb` 存储的配置。您可以：

1.  通过 `clientConfig` 属性传递 [DynamoDB 配置](https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/Package/-aws-sdk-client-dynamodb/Interface/DynamoDBClientConfig/)，或
2.  通过 `client` 属性传递 DynamoDB 实例。

<!-- end list -->

```ts
// title: 使用客户端配置
stores.dynamodb({
  clientConfig: {
    region: 'us-east-1',
    endpoint: '<database-endpoint>',
    credentials: {
      accessKeyId: '',
      secretAccessKey: '',
    }
  },
})
```

```ts
// title: 使用客户端实例
import { DynamoDBClient } from '@aws-sdk/client-dynamodb'
const client = new DynamoDBClient({})

stores.dynamodb({
  client,
})
```

此外，您可以定义自定义的表名和键属性名。

```ts
stores.dynamodb({
  tableName: 'Session',
  keyAttribute: 'key'
})
```

\</dd\>

\</dl\>

-----

### 更新环境变量验证 (Updating environment variables validation)

如果您决定使用**除默认存储以外**的会话存储，请确保也更新 **`SESSION_DRIVER` 环境变量**的环境变量验证。

在以下示例中，我们配置了 `cookie`、`redis` 和 `dynamodb` 存储。因此，我们也应该允许 `SESSION_DRIVER` 环境变量是它们之一。

```ts
import { defineConfig, stores } from '@adonisjs/session'

export default defineConfig({
  // ...
  store: env.get('SESSION_DRIVER'),

  stores: {
    cookie: stores.cookie(),
    redis: stores.redis({
      connection: 'main'
    }),
    dynamodb: stores.dynamodb({ /* ... */ }), // 假设已配置 dynamodb
  }
  // ...
})
```

```ts
// title: start/env.ts
{
  // 必须允许配置的所有驱动
  SESSION_DRIVER: Env.schema.enum(['cookie', 'redis', 'dynamodb', 'memory'] as const) 
}
```

-----

## 基本示例 (Basic example)

注册会话包后，您可以从 [HTTP Context](https://www.google.com/search?q=../concepts/http_context.md) 访问 **`session` 属性**。`session` 属性公开了用于**读取和写入数据到会话存储**的 API。

```ts
import router from '@adonisjs/core/services/router'

router.get('/theme/:color', async ({ params, session, response }) => {
  // 使用 session.put 写入数据
  session.put('theme', params.color) 
  response.redirect('/')
})

router.get('/', async ({ session }) => {
  // 使用 session.get 读取数据
  const colorTheme = session.get('theme') 
  return `You are using ${colorTheme} color theme`
})
```

会话数据在**请求开始时**从会话存储中读取，并在**请求结束时**写回到存储中。因此，所有更改都保留在内存中，直到请求完成。

-----

## 支持的数据类型 (Supported data types)

会话数据使用 `JSON.stringify` **序列化为字符串**；因此，您可以使用以下 JavaScript 数据类型作为会话值。

  * string
  * number
  * bigInt
  * boolean
  * null
  * object
  * array

<!-- end list -->

```ts
// Object
session.put('user', {
  id: 1,
  fullName: 'virk',
})

// Array
session.put('product_ids', [1, 2, 3, 4])

// Boolean
session.put('is_logged_in', true)

// Number
session.put('visits', 10)

// BigInt
session.put('visits', BigInt(10))

// Date 对象被转换为 ISO 字符串
session.put('visited_at', new Date())
```

-----

## 读取和写入数据 (Reading and writing data)

以下是可用于与 `session` 对象数据进行交互的方法列表。

### get

从存储中返回一个键的值。您可以使用**点记法**来读取嵌套值。

```ts
session.get('key')
session.get('user.email')
```

您还可以将**默认值**定义为第二个参数。如果存储中不存在该键，则返回默认值。

```ts
session.get('visits', 0)
```

### has

检查会话存储中是否存在一个键。

```ts
if (session.has('visits')) {
}
```

### all

返回会话存储中的**所有数据**。返回值始终是一个对象。

```ts
session.all()
```

### put

向会话存储添加一个键值对。您可以使用**点记法**创建具有嵌套值的对象。

```ts
session.put('user', { email: 'foo@bar.com' })

// 与上面相同
session.put('user.email', 'foo@bar.com')
```

### forget

从会话存储中移除一个键值对。

```ts
session.forget('user')

// 从 user 对象中移除 email
session.forget('user.email')
```

### pull

`pull` 方法**返回一个键的值**，并同时将其**从存储中移除**。

```ts
const user = session.pull('user')
session.has('user') // false
```

### increment

`increment` 方法**增加**一个键的值。如果该键尚不存在，则定义一个新的键值（默认为 1）。

```ts
session.increment('visits')

// 增加 4
session.increment('visits', 4)
```

### decrement

`decrement` 方法**减少**一个键的值。如果该键尚不存在，则定义一个新的键值（默认为 -1）。

```ts
session.decrement('visits')

// 减少 4
session.decrement('visits', 4)
```

### clear

`clear` 方法**移除**会话存储中的所有内容。

```ts
session.clear()
```

-----

## 会话生命周期 (Session lifecycle)

AdonisJS 在**第一次 HTTP 请求时**创建一个**空**的会话存储，并为其分配一个**唯一的会话 ID**，即使请求/响应生命周期没有与会话进行交互。

在**后续的每次请求中**，我们会更新会话 ID Cookie 的 `maxAge` 属性，以确保它不会过期。会话存储也会收到有关更改（如果有）的通知，以更新和持久化它们。

您可以使用 **`sessionId` 属性**访问唯一的会话 ID。访问者的会话 ID 保持不变，直到它过期。

```ts
console.log(session.sessionId)
```

### 重新生成会话 ID (Re-generating session id)

重新生成会话 ID 有助于防止应用程序中的 [会话固定 (session fixation)](https://owasp.org/www-community/attacks/Session_fixation) 攻击。当将**匿名会话**与**已登录用户**关联时，您必须**重新生成会话 ID**。

`@adonisjs/auth` 包会自动重新生成会话 ID，因此您**不必手动**执行此操作。

```ts
/**
 * 新的会话 ID 将在请求结束时分配
 */
session.regenerate()
```

-----

## Flash 消息 (Flash messages)

**Flash 消息**用于在**两个 HTTP 请求之间传递数据**。它们通常用于在特定操作后向用户提供反馈。例如，在表单提交后显示成功消息或显示验证错误消息。

在以下示例中，我们定义了用于显示联系表单和将表单详细信息提交到数据库的路由。表单提交后，我们使用 Flash 消息重定向用户回到表单，并附带成功通知。

```ts
import router from '@adonisjs/core/services/router'

router.post('/contact', ({ session, request, response }) => {
  const data = request.all()
  // 保存联系数据
  
  // 使用 session.flash 写入 Flash 消息
  session.flash('notification', { 
    type: 'success',
    message: 'Thanks for contacting. We will get back to you'
  })

  response.redirect().back()
})

router.get('/contact', ({ view }) => {
  return view.render('contact')
})
```

您可以使用 **`@flashMessage` 标签**或 **`flashMessages` 属性**在 Edge 模板中访问 Flash 消息。

```edge
{{-- 检查是否存在键为 'notification' 的 Flash 消息 --}}
@flashMessage('notification') 
  <div class="notification {{ $message.type }}">
    {{ $message.message }} {{-- $message 是 flash 消息的值 --}}
  </div>
@end

<form method="POST" action="/contact">
  </form>
```

您可以使用 **`session.flashMessages` 属性**在控制器内部访问 Flash 消息。

```ts
router.get('/contact', ({ view, session }) => {
  console.log(session.flashMessages.all()) // 获取所有 Flash 消息
  return view.render('contact')
})
```

### 验证错误和 Flash 消息 (Validation errors and flash messages)

Session 中间件会自动捕获 [验证异常](https://www.google.com/search?q=./validation.md%23error-handling)，并将用户重定向回表单。验证错误和表单输入数据保留在 Flash 消息中，您可以在 Edge 模板中访问它们。

在以下示例中：

  - 我们使用 [`old` 方法](https://www.google.com/search?q=../references/edge.md%23old) 访问 `title` 输入字段的值。
  - 并使用 **`@inputError` 标签**访问错误消息。

<!-- end list -->

```edge
<form method="POST" action="/posts">
  <div>
    <label for="title"> Title </label>
    <input 
      type="text"
      id="title"
      name="title"
      value="{{ old('title') || '' }}" {{-- 从 Flash 消息中获取旧输入值 --}}
    />

    @inputError('title') {{-- 检查 'title' 字段的验证错误 --}}
      @each(message in $messages)
        <p> {{ message }} </p>
      @end
    @end
  </div>
</form>
```

### 写入 Flash 消息 (Writing flash messages)

以下是将数据写入 Flash 消息存储的方法。**`session.flash(key, value)` 方法**接受一个键值对，并将其写入会话存储中的 Flash 消息属性。

```ts
session.flash('key', value)
session.flash({
  key: value // 可以传递一个对象
})
```

您可以不是手动读取请求数据并将其存储在 Flash 消息中，而是使用以下方法之一来 **Flash 表单数据**。

```ts
// title: flashAll
/**
 * 闪存所有请求数据的简写
 */
session.flashAll()

/**
 * 与 "flashAll" 相同
 */
session.flash(request.all())
```

```ts
// title: flashOnly
/**
 * 仅闪存请求数据中选定属性的简写
 */
session.flashOnly(['username', 'email'])

/**
 * 与 "flashOnly" 相同
 */
session.flash(request.only(['username', 'email']))
```

```ts
// title: flashExcept
/**
 * 闪存请求数据中除选定属性外的简写
 */
session.flashExcept(['password'])

/**
 * 与 "flashExcept" 相同
 */
session.flash(request.except(['password']))
```

最后，您可以使用 **`session.reflash` 方法**重新闪存当前的 Flash 消息（使其在再下一个请求中仍然可用）。

```ts
session.reflash() // 重新闪存所有当前的 Flash 消息
session.reflashOnly(['notification', 'errors']) // 仅重新闪存选定的消息
session.reflashExcept(['errors']) // 重新闪存除选定消息外的所有消息
```

### 读取 Flash 消息 (Reading flash messages)

Flash 消息仅在**重定向后的下一个请求中**可用。您可以使用 **`session.flashMessages` 属性**访问它们。

```ts
console.log(session.flashMessages.all())
console.log(session.flashMessages.get('key'))
console.log(session.flashMessages.has('key'))
```

相同的 `flashMessages` 属性也与 Edge 模板共享，您可以按如下方式访问它。

另请参阅：[Edge helpers reference](https://www.google.com/search?q=../references/edge.md%23flashmessages)

```edge
{{ flashMessages.all() }}
{{ flashMessages.get('key') }}
{{ flashMessages.has('key') }}
```

最后，您可以使用以下 Edge 标签访问特定的 Flash 消息或验证错误。

```edge
{{-- 通过键读取任何 Flash 消息 --}}
@flashMessage('key')
  {{ inspect($message) }}
@end

{{-- 读取通用错误（例如非验证错误） --}}
@error('key')
  {{ inspect($message) }}
@end

{{-- 读取验证错误 --}}
@inputError('key')
  {{ inspect($messages) }}
@end
```

-----

## 事件 (Events)

请查看 [事件参考指南](https://www.google.com/search?q=../references/events.md%23sessioninitiated) 以查看 `@adonisjs/session` 包分派的事件列表。

-----

## 创建自定义会话存储 (Creating a custom session store)

会话存储必须实现 **`SessionStoreContract` 接口**并定义以下方法。

```ts
import {
  SessionData,
  SessionStoreFactory,
  SessionStoreContract,
} from '@adonisjs/session/types'

/**
 * 您想要接受的配置类型
 */
export type MongoDBConfig = {}

/**
 * 驱动实现
 */
export class MongoDBStore implements SessionStoreContract {
  constructor(public config: MongoDBConfig) {
  }

  /**
   * 返回会话 ID 的会话数据。该方法必须返回 null 或键值对对象
   */
  async read(sessionId: string): Promise<SessionData | null> {
  }

  /**
   * 针对提供的会话 ID 保存会话数据
   */
  async write(sessionId: string, data: SessionData): Promise<void> {
  }

  /**
   * 删除给定会话 ID 的会话数据
   */
  async destroy(sessionId: string): Promise<void> {
  }

  /**
   * 重置会话过期时间
   */
  async touch(sessionId: string): Promise<void> {
  }
}

/**
 * 用于在配置文件中引用存储的工厂函数。
 */
export function mongoDbStore (config: MongoDbConfig): SessionStoreFactory {
  return (ctx, sessionConfig) => {
    return new MongoDBStore(config)
  }
}
```

在上面的代码示例中，我们导出了以下值：

  * `MongoDBConfig`：您想要接受的配置的 TypeScript 类型。
  * `MongoDBStore`：作为类的存储实现。它必须遵守 `SessionStoreContract` 接口。
  * `mongoDbStore`：最后，一个**工厂函数**，用于为每个 HTTP 请求创建存储的实例。

### 使用存储 (Using the store)

创建存储后，您可以使用 `mongoDbStore` **工厂函数**在配置文件中引用它。

```ts
// title: config/session.ts
import { defineConfig } from '@adonisjs/session'
// 从您的自定义包中导入工厂函数
import { mongDbStore } from 'my-custom-package' 

export default defineConfig({
  stores: {
    mongodb: mongoDbStore({
      // 您的自定义配置在这里
    })
  }
})
```

### 关于序列化数据的说明 (A note on serializing data)

`write` 方法接收会话数据作为一个对象，您可能需要将其**转换为字符串**后再保存。您可以使用任何序列化包，或者使用 AdonisJS 辅助模块提供的 [MessageBuilder](https://www.google.com/search?q=../references/helpers.md%23message-builder) 辅助函数。有关灵感，请查阅官方 [会话存储](https://github.com/adonisjs/session/blob/main/src/stores/redis.ts#L59)。