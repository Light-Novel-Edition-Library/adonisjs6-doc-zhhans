# 脚手架和代码修改工具 (Scaffolding and codemods)

脚手架 (Scaffolding) 指的是从静态模板（即**存根 (stubs)**）生成源文件的过程，而代码修改工具 (codemods) 指的是通过解析 **AST (抽象语法树)** 来更新 TypeScript 源代码。

AdonisJS 同时使用这两种方法来加快创建新文件和配置包的重复性任务。在本指南中，我们将介绍脚手架的构建块，并涵盖您可以在 Ace 命令中使用的代码修改工具 API。

-----

## 构建块 (Building blocks)

### 存根 (Stubs)

存根指的是用于在给定操作上创建源文件的**模板**。例如，`make:controller` 命令使用[控制器存根](https://github.com/adonisjs/core/blob/main/stubs/make/controller/main.stub)在宿主项目内创建控制器文件。

### 生成器 (Generators)

生成器强制执行**命名约定**，并根据预定义的约定生成文件、类或方法名称。

例如，控制器存根使用 [controllerName](https://github.com/adonisjs/application/blob/main/src/generators.ts#L122) 和 [controllerFileName](https://github.com/adonisjs/application/blob/main/src/generators.ts#L139) 生成器来创建控制器。

由于生成器被定义为一个对象，您可以覆盖现有方法来调整约定。我们将在本指南后面了解更多相关信息。

### 代码修改工具 (Codemods)

代码修改工具 API 来自于 **[@adonisjs/assembler](https://github.com/adonisjs/assembler/blob/main/src/code_transformer/main.ts)** 包，它在底层使用了 [ts-morph](https://github.com/dsherret/ts-morph)。

由于 `@adonisjs/assembler` 是一个开发依赖项，`ts-morph` 不会使您的项目依赖项在生产环境中膨胀。这也意味着，代码修改工具 API 在生产环境中不可用。

AdonisJS 暴露的代码修改工具 API 是**非常具体**的，旨在完成高级任务，例如**将提供者添加到 `.adonisrc.ts` 文件**，或**在 `start/kernel.ts` 文件中注册中间件**。此外，这些 API 依赖于默认的命名约定，因此如果您对项目进行了剧烈的更改，您将无法运行代码修改工具。

### 配置命令 (Configure command)

配置命令用于配置 AdonisJS 包。在底层，此命令导入主入口点文件并执行所述包导出的 `configure` 方法。

包的 `configure` 方法接收 [Configure command](https://github.com/adonisjs/core/blob/main/commands/configure.ts) 的一个实例，因此，它可以直接从命令实例访问存根和代码修改工具 API。

-----

## 使用存根 (Using stubs)

大多数时候，您会在 Ace 命令中或在您创建的包的 `configure` 方法内部使用存根。在这两种情况下，您都可以通过 Ace 命令的 `createCodemods` 方法初始化代码修改工具模块。

`codemods.makeUsingStub` 方法从存根模板创建一个源文件。它接受以下参数：

1.  存根存储的根目录的 URL。
2.  从 `STUBS_ROOT` 目录到存根文件（包括扩展名）的相对路径。
3.  用于与存根共享的数据对象。

<!-- end list -->

```ts
// title: Inside a command
import { BaseCommand } from '@adonisjs/core/ace'

const STUBS_ROOT = new URL('./stubs', import.meta.url)

export default class MakeApiResource extends BaseCommand {
  async run() {
    // highlight-start
    const codemods = await this.createCodemods()
    await codemods.makeUsingStub(STUBS_ROOT, 'api_resource.stub', {})
    // highlight-end
  }
}
```

### 存根模板 (Stubs templating)

我们使用 **[Tempura](https://github.com/lukeed/tempura)** 模板引擎来处理带有运行时数据的存根。Tempura 是一个用于 JavaScript 的超轻量级 Handlebars 风格的模板引擎。

:::tip

由于 Tempura 的语法与 Handlebars 兼容，您可以将代码编辑器设置为对 `.stub` 文件使用 Handlebars 语法高亮显示。

:::

在以下示例中，我们创建了一个输出 JavaScript 类的存根。它使用**双大括号**来评估运行时值。

```handlebars
export default class {{ modelName }}Resource {
  serialize({{ modelReference }}: {{ modelName }}) {
    return {{ modelReference }}.toJSON()
  }
}
```

### 使用生成器 (Using generators)

如果您现在执行上面的存根，它将失败，因为我们尚未提供 `modelName` 和 `modelReference` 数据属性。

我们建议使用**内联变量**在存根内部计算这些属性。这样，宿主应用程序就可以[弹出存根](https://www.google.com/search?q=%23ejecting-stubs)并修改变量。

```js
// insert-start
{{#var entity = generators.createEntity('user')}}
{{#var modelName = generators.modelName(entity.name)}}
{{#var modelReference = string.camelCase(modelName)}}
// insert-end

export default class {{ modelName }}Resource {
  serialize({{ modelReference }}: {{ modelName }}) {
    return {{ modelReference }}.toJSON()
  }
}
```

### 输出目的地 (Output destination)

最后，我们必须指定将使用存根创建的文件的**目标路径**。我们再次在存根文件内部指定目标路径，因为它允许宿主应用程序[弹出存根](https://www.google.com/search?q=%23ejecting-stubs)并自定义其输出目的地。

目标路径是使用 `exports` 函数定义的。该函数接受一个对象并将其导出作为存根的**输出状态**。随后，代码修改工具 API 使用此对象在所述位置创建文件。

```js
{{#var entity = generators.createEntity('user')}}
{{#var modelName = generators.modelName(entity.name)}}
{{#var modelReference = string.camelCase(modelName)}}
// insert-start
{{#var resourceFileName = string(modelName).snakeCase().suffix('_resource').ext('.ts').toString()}}
{{{
  exports({
    to: app.makePath('app/api_resources', entity.path, resourceFileName)
  })
}}}
// insert-end
export default class {{ modelName }}Resource {
  serialize({{ modelReference }}: {{ modelName }}) {
    return {{ modelReference }}.toJSON()
  }
}
```

### 通过命令接受实体名称 (Accepting entity name via command)

现在，我们在存根内部将实体名称硬编码为 `user`。但是，您应该将其作为**命令参数**接受，并将其作为模板状态与存根共享。

```ts
import { BaseCommand, args } from '@adonisjs/core/ace'

export default class MakeApiResource extends BaseCommand {
  // insert-start
  @args.string({
    description: 'The name of the resource'
  })
  declare name: string
  // insert-end

  async run() {
    const codemods = await this.createCodemods()
    await codemods.makeUsingStub(STUBS_ROOT, 'api_resource.stub', {
      // insert-start
      name: this.name,
      // insert-end
    })
  }
}
```

```js
// delete-start
{{#var entity = generators.createEntity('user')}}
// delete-end
// insert-start
{{#var entity = generators.createEntity(name)}}
// insert-end
{{#var modelName = generators.modelName(entity.name)}}
{{#var modelReference = string.camelCase(modelName)}}
{{#var resourceFileName = string(modelName).snakeCase().suffix('_resource').ext('.ts').toString()}}
{{{
  exports({
    to: app.makePath('app/api_resources', entity.path, resourceFileName)
  })
}}}
export default class {{ modelName }}Resource {
  serialize({{ modelReference }}: {{ modelName }}) {
    return {{ modelReference }}.toJSON()
  }
}
```

### 全局变量 (Global variables)

以下全局变量总是与存根共享。

| 变量 | 描述 |
| :--- | :--- |
| `app` | [Application 类](https://www.google.com/search?q=./application.md)实例的引用。 |
| `generators` | [生成器模块](https://github.com/adonisjs/application/blob/main/src/generators.ts)的引用。 |
| `randomString` | [randomString](https://www.google.com/search?q=../references/helpers.md%23random) 辅助函数的引用。 |
| `string` | 创建[字符串构建器](https://www.google.com/search?q=../references/helpers.md%23string-builder)实例的函数。您可以使用字符串构建器对字符串应用转换。 |
| `flags` | 运行 ace 命令时定义的命令行标志。 |

-----

## 弹出存根 (Ejecting stubs)

您可以使用 `node ace eject` 命令在 AdonisJS 应用程序内部**弹出/复制**存根。`eject` 命令接受原始存根文件或其父目录的路径，并将模板复制到项目根目录的 `stubs` 目录内。

在以下示例中，我们将从 `@adonisjs/core` 包复制 `make/controller/main.stub` 文件。

```sh
node ace eject make/controller/main.stub
```

如果您打开存根文件，它将具有以下内容。

```js
{{#var controllerName = generators.controllerName(entity.name)}}
{{#var controllerFileName = generators.controllerFileName(entity.name)}}
{{{
  exports({
    to: app.httpControllersPath(entity.path, controllerFileName)
  })
}}}
// import type { HttpContext } from '@adonisjs/core/http'

export default class {{ controllerName }} {
}
```

  * 在前两行中，我们使用[生成器模块](https://github.com/adonisjs/application/blob/main/src/generators.ts)来生成控制器类名和控制器文件名。
  * 在第 3-7 行，我们使用 `exports` 函数为控制器文件[定义目标路径](https://www.google.com/search?q=%23using-cli-flags-to-customize-stub-output-destination)。
  * 最后，我们定义脚手架生成的控制器内容。

随意修改存根。下次运行 `make:controller` 命令时，更改将被拾取。

### 弹出目录 (Ejecting directories)

您可以使用 `eject` 命令弹出整个存根目录。传入目录的路径，命令将复制整个目录。

```sh
# 发布所有 make 存根
node ace eject make

# 发布所有 make:controller 存根
node ace eject make/controller
```

### 使用 CLI 标志自定义存根输出目的地 (Using CLI flags to customize stub output destination)

所有脚手架命令都会与存根模板共享 CLI 标志（包括不受支持的标志）。因此，您可以使用它们来创建自定义工作流或更改输出目的地。

在以下示例中，我们使用 `--feature` 标志在所述的功能目录内创建控制器。

```sh
node ace make:controller invoice --feature=billing
```

```js
// title: Controller stub
{{#var controllerName = generators.controllerName(entity.name)}}
// insert-start
{{#var featureDirectoryName = flags.feature}}
// insert-end
{{#var controllerFileName = generators.controllerFileName(entity.name)}}
{{{
  exports({
    // delete-start
    to: app.httpControllersPath(entity.path, controllerFileName)
    // delete-end
    // insert-start
    to: app.makePath('features', featureDirectoryName, controllerFileName)
    // insert-end
  })
}}}
// import type { HttpContext } from '@adonisjs/core/http'

export default class {{ controllerName }} {
}
```

### 弹出其他包的存根 (Ejecting stubs from other packages)

默认情况下，`eject` 命令从 `@adonisjs/core` 包复制模板。但是，您可以使用 `--pkg` 标志从其他包复制存根。

```sh
node ace eject make/migration/main.stub --pkg=@adonisjs/lucid
```

### 如何查找要复制的存根？ (How do you find which stubs to copy?)

您可以通过访问包的 GitHub 仓库来查找它的存根。我们将所有存根存储在包根目录内的 `stubs` 目录中。

-----

## 存根执行流程 (Stubs execution flow)

以下是我们通过 `makeUsingStub` 方法查找和执行存根的可视化表示。

-----

## 代码修改工具 API (Codemods API)

代码修改工具 API 由 [ts-morph](https://github.com/dsherret/ts-morph) 提供支持，并且**仅在开发期间可用**。您可以使用 `command.createCodemods` 方法**延迟实例化**代码修改工具模块。`createCodemods` 方法返回 [Codemods](https://github.com/adonisjs/core/blob/main/modules/ace/codemods.ts) 类的一个实例。

```ts
import type Configure from '@adonisjs/core/commands/configure'

export async function configure(command: ConfigureCommand) {
  const codemods = await command.createCodemods()
}
```

### defineEnvValidations

定义环境变量的验证规则。该方法接受变量的键值对。**`key` 是环境变量名称**，**`value` 是作为字符串的验证表达式**。

:::note
此代码修改工具期望 `start/env.ts` 文件存在，并且必须包含 `export default await Env.create` 方法调用。

此外，此代码修改工具不会覆盖给定环境变量的现有验证规则。这样做是为了尊重应用程序内的修改。
:::

```ts
const codemods = await command.createCodemods()

try {
  await codemods.defineEnvValidations({
    leadingComment: 'App environment variables',
    variables: {
      PORT: 'Env.schema.number()',
      HOST: 'Env.schema.string()',
    }
  })
} catch (error) {
  console.error('Unable to define env validations')
  console.error(error)
}
```

```ts
// title: Output
import { Env } from '@adonisjs/core/env'

export default await Env.create(new URL('../', import.meta.url), {
  /**
   * App environment variables
   */
  PORT: Env.schema.number(),
  HOST: Env.schema.string(),
})
```

### defineEnvVariables

向 `.env` 和 `.env.example` 文件添加一个或多个新环境变量。该方法接受变量的键值对。

```ts
const codemods = await command.createCodemods()

try {
  await codemods.defineEnvVariables({
    MY_NEW_VARIABLE: 'some-value',
    MY_OTHER_VARIABLE: 'other-value'
  })
} catch (error) {
  console.error('Unable to define env variables')
  console.error(error)
}
```

有时，您可能希望**不**将变量值插入到 `.env.example` 文件中。您可以通过使用 `omitFromExample` 选项来实现。

```ts
const codemods = await command.createCodemods()

await codemods.defineEnvVariables({
  MY_NEW_VARIABLE: 'SOME_VALUE',
}, {
  omitFromExample: ['MY_NEW_VARIABLE']
})
```

上面的代码将在 `.env` 文件中插入 `MY_NEW_VARIABLE=SOME_VALUE`，并在 `.env.example` 文件中插入 `MY_NEW_VARIABLE=`。

### registerMiddleware

将 AdonisJS 中间件注册到其中一个已知的中间件栈。该方法接受**中间件栈**和一个要注册的中间件数组。

中间件栈可以是 `server`、`router` 或 `named` 之一。

:::note
此代码修改工具期望 `start/kernel.ts` 文件存在，并且必须包含您尝试为其注册中间件的中间件栈的函数调用。
:::

```ts
const codemods = await command.createCodemods()

try {
  await codemods.registerMiddleware('router', [
    {
      path: '@adonisjs/core/bodyparser_middleware'
    }
  ])
} catch (error) {
  console.error('Unable to register middleware')
  console.error(error)
}
```

```ts
// title: Output
import router from '@adonisjs/core/services/router'

router.use([
  () => import('@adonisjs/core/bodyparser_middleware')
])
```

您可以按如下方式定义命名中间件。

```ts
const codemods = await command.createCodemods()

try {
  await codemods.registerMiddleware('named', [
    {
      name: 'auth',
      path: '@adonisjs/auth/auth_middleware'
    }
  ])
} catch (error) {
  console.error('Unable to register middleware')
  console.error(error)
}
```

### updateRcFile

将 `providers`、`commands` 注册到 `adonisrc.ts` 文件，定义 `metaFiles` 和 `commandAliases`。

:::note
此代码修改工具期望 `adonisrc.ts` 文件存在，并且必须包含 `export default defineConfig` 函数调用。
:::

```ts
const codemods = await command.createCodemods()

try {
  await codemods.updateRcFile((rcFile) => {
    rcFile
      .addProvider('@adonisjs/lucid/db_provider')
      .addCommand('@adonisjs/lucid/commands'),
      .setCommandAlias('migrate', 'migration:run')
  })
} catch (error) {
  console.error('Unable to update adonisrc.ts file')
  console.error(error)  
}
```

```ts
// title: Output
import { defineConfig } from '@adonisjs/core/app'

export default defineConfig({
  commands: [
    () => import('@adonisjs/lucid/commands')
  ],
  providers: [
    () => import('@adonisjs/lucid/db_provider')
  ],
  commandAliases: {
    migrate: 'migration:run'
  }
})
```

### registerJapaPlugin

向 `tests/bootstrap.ts` 文件注册一个 Japa 插件。

:::note
此代码修改工具期望 `tests/bootstrap.ts` 文件存在，并且必须包含 `export const plugins: Config['plugins']` 导出。
:::

```ts
const codemods = await command.createCodemods()

const imports = [
  {
    isNamed: false,
    module: '@adonisjs/core/services/app',
    identifier: 'app'
  },
  {
    isNamed: true,
    module: '@adonisjs/session/plugins/api_client',
    identifier: 'sessionApiClient'
  }
]
const pluginUsage = 'sessionApiClient(app)'

try {
  await codemods.registerJapaPlugin(pluginUsage, imports)
} catch (error) {
  console.error('Unable to register japa plugin')
  console.error(error)
}
```

```ts
// title: Output
import app from '@adonisjs/core/services/app'
import { sessionApiClient } from '@adonisjs/session/plugins/api_client'

export const plugins: Config['plugins'] = [
  sessionApiClient(app)
]
```

### registerPolicies

将 AdonisJS 守卫策略注册到从 `app/policies/main.ts` 文件导出的 `policies` 对象列表中。

:::note
此代码修改工具期望 `app/policies/main.ts` 文件存在，并且必须从中导出一个 `policies` 对象。
:::

```ts
const codemods = await command.createCodemods()

try {
  await codemods.registerPolicies([
    {
      name: 'PostPolicy',
      path: '#policies/post_policy'
    }
  ])
} catch (error) {
  console.error('Unable to register policy')
  console.error(error)
}
```

```ts
// title: Output
export const policies = {
  PostPolicy: () => import('#policies/post_policy')
}
```

### registerVitePlugin

向 `vite.config.ts` 文件注册一个 Vite 插件。

:::note
此代码修改工具期望 `vite.config.ts` 文件存在，并且必须包含 `export default defineConfig` 函数调用。
:::

```ts
const transformer = new CodeTransformer(appRoot)
const imports = [
  {
    isNamed: false,
    module: '@vitejs/plugin-vue',
    identifier: 'vue'
  },
]
const pluginUsage = 'vue({ jsx: true })'

try {
  await transformer.addVitePlugin(pluginUsage, imports)
} catch (error) {
  console.error('Unable to register vite plugin')
  console.error(error)
}
```

```ts
// title: Output
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [
    vue({ jsx: true })
  ]
})
```

### installPackages

使用用户项目中的检测到的包管理器安装一个或多个包。

```ts
const codemods = await command.createCodemods()

try {
  await codemods.installPackages([
    { name: 'vinejs', isDevDependency: false },
    { name: 'edge', isDevDependency: false }
  ])
} catch (error) {
  console.error('Unable to install packages')
  console.error(error)
}
```

### getTsMorphProject

`getTsMorphProject` 方法返回 `ts-morph` 的一个实例。当您想要执行代码修改工具 API 未涵盖的自定义文件转换时，这会很有用。

```ts
const project = await codemods.getTsMorphProject()

project.getSourceFileOrThrow('start/routes.ts')
```

请务必阅读 [ts-morph 文档](https://ts-morph.com/)以了解有关可用 API 的更多信息。