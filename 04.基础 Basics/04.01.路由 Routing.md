# 路由 (Routing)

您的网站或 Web 应用程序的用户可以访问不同的 URL，例如 `/`、`/about` 或 `/posts/1`。为了使这些 URL 生效，您必须定义**路由 (routes)**。

在 AdonisJS 中，路由定义在 `start/routes.ts` 文件中。路由是**URI 模式 (URI pattern)** 和用于处理该特定路由的**处理程序 (handler)** 的组合。例如：

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'

router.get('/', () => {
  return 'Hello world from the home page.'
})

router.get('/about', () => {
  return 'This is the about page.'
})

router.get('/posts/:id', ({ params }) => {
  return `This is post with id ${params.id}`
})
```

上面示例中的最后一条路由使用了**动态 URI 模式**。`:id` 是一种告诉路由器接受 `id` 任何值的方式。我们称它们为**路由参数 (route params)**。

## 查看已注册路由列表 (View list of registered routes)

您可以运行 `list:routes` 命令来查看应用程序已注册的路由列表。

```sh
node ace list:routes
```

此外，如果您正在使用我们的[官方 VSCode 扩展](https://marketplace.visualstudio.com/items?itemName=jripouteau.adonis-vscode-extension)，您还可以从 VSCode 活动栏中查看路由列表。

-----

## 路由参数 (Route params)

路由参数允许您定义可以接受**动态值**的 URI。每个参数捕获 URI 段的值，您可以在路由处理程序中访问该值。

路由参数总是以**冒号 `:`** 开头，后跟参数的名称。

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'

router.get('/posts/:id', ({ params }) => {
  return params.id
})
```

| URL | Id |
| :--- | :--- |
| `/posts/1` | `1` |
| `/posts/100` | `100` |
| `/posts/foo-bar` | `foo-bar` |

一个 URI 也可以接受**多个参数**。每个参数都应该有一个唯一的名称。

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'

router.get('/posts/:id/comments/:commentId', ({ params }) => {
  console.log(params.id)
  console.log(params.commentId)
})
```

| URL | Id | Comment Id |
| :--- | :--- | :--- |
| `/posts/1/comments/4` | `1` | `4` |
| `/posts/foo-bar/comments/22` | `foo-bar` | `22` |

### 可选参数 (Optional params)

路由参数也可以是**可选的**，方法是在参数名称末尾附加一个**问号 `?`**。可选参数应位于必需参数之后。

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'

router.get('/posts/:id?', ({ params }) => {
  if (!params.id) {
    return 'Showing all posts'
  }

  return `Showing post with id ${params.id}`
})
```

### 通配符参数 (Wildcard params)

要捕获 URI 的所有片段，您可以定义一个**通配符参数 (wildcard param)**。通配符参数使用特殊的 **`*` 关键字**指定，并且必须定义在**最后一个位置**。

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'

router.get('/docs/:category/*', ({ params }) => {
  console.log(params.category)
  console.log(params['*'])
})
```

| URL | Category | Wildcard param |
| :--- | :--- | :--- |
| `/docs/http/context` | `http` | `['context']` |
| `/docs/api/sql/orm` | `api` | `['sql', 'orm']` |

### 参数匹配器 (Params matchers)

路由器不知道您想要接受的参数数据的格式。例如，URI 为 `/posts/foo-bar` 和 `/posts/1` 的请求将匹配同一条路由。但是，您可以使用**参数匹配器**显式验证参数值。

匹配器通过链式调用 **`where()` 方法**来注册。第一个参数是**参数名称**，第二个参数是**匹配器对象**。

在以下示例中，我们定义了一个正则表达式来验证 `id` 是一个有效的数字。如果验证失败，该路由将被跳过。

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'

router
  .get('/posts/:id', ({ params }) => {})
  .where('id', {
    match: /^[0-9]+$/, // 匹配数字的正则表达式
  })
```

除了 `match` 正则表达式之外，您还可以定义一个 **`cast` 函数**将参数值转换为其正确的数据类型。在此示例中，我们可以将 id 转换为数字。

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'

router
  .get('/posts/:id', ({ params }) => {
    console.log(typeof params.id) // 输出 'number'
  })
  .where('id', {
    match: /^[0-9]+$/,
    cast: (value) => Number(value), // 转换为 number 类型
  })
```

### 内置匹配器 (Inbuilt matchers)

路由器附带了以下用于常用数据类型的辅助方法。

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'

// 验证 id 为数字 + 转换为 number 数据类型
router.where('id', router.matchers.number())

// 验证 id 为有效的 UUID
router.where('id', router.matchers.uuid())

// 验证 slug 匹配给定的 slug 正则表达式: regexr.com/64su0
router.where('slug', router.matchers.slug())
```

### 全局匹配器 (Global matchers)

路由匹配器可以在**路由器实例上全局定义**。除非在路由级别被明确覆盖，否则全局匹配器将应用于所有路由。

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'

// 全局匹配器 (应用于所有路由)
router.where('id', router.matchers.uuid())

router
  .get('/posts/:id', () => {})
  // 在路由级别覆盖 (仅此路由应用 number 匹配器)
  .where('id', router.matchers.number()) 
```

-----

## HTTP 方法 (HTTP methods)

`router.get()` 方法创建一条响应 [GET HTTP 方法](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET) 的路由。类似地，您可以使用以下方法注册不同 HTTP 方法的路由。

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'

// GET 方法
router.get('users', () => {})

// POST 方法
router.post('users', () => {})

// PUT 方法
router.put('users/:id', () => {})

// PATCH 方法
router.patch('users/:id', () => {})

// DELETE 方法
router.delete('users/:id', () => {})
```

您可以使用 **`router.any()`** 方法创建一条响应**所有标准 HTTP 方法**的路由。

```ts
// title: start/routes.ts
router.any('reports', () => {})
```

最后，您可以使用 **`router.route()`** 方法为**自定义 HTTP 方法**创建路由。

```ts
// title: start/routes.ts
router.route('/', ['TRACE'], () => {})
```

-----

## 路由处理程序 (Router handler)

路由处理程序通过返回响应或抛出异常来中止请求以处理请求。

处理程序可以是**内联回调**（如本指南所示）或**对控制器方法的引用**。

```ts
// title: start/routes.ts
router.post('users', () => {
  // 执行某些操作
})
```

:::note

路由处理程序可以是异步函数 (`async function`)，AdonisJS 将自动处理 Promise 的解析。

:::

在以下示例中，我们导入 `UsersController` 类并将其绑定到路由。在 HTTP 请求期间，AdonisJS 将使用 **IoC 容器**创建一个控制器类的实例并执行 `store` 方法。

另请参阅：关于[控制器的专门指南](https://www.google.com/search?q=./controllers.md)。

```ts
// title: start/routes.ts
const UsersController = () => import('#controllers/users_controller')

// 将 POST 'users' 路由映射到 UsersController 的 store 方法
router.post('users', [UsersController, 'store'])
```

-----

## 路由中间件 (Route middleware)

您可以通过链式调用 **`use()` 方法**在路由上定义一个**中间件**。该方法接受一个内联回调或对**命名中间件**的引用。

以下是定义路由中间件的最小示例。我们建议阅读[关于中间件的专门指南](https://www.google.com/search?q=./middleware.middleware.md)以探索所有可用选项和中间件的执行流程。

```ts
// title: start/routes.ts
router
  .get('posts', () => {
    console.log('Inside route handler') // 步骤 2: 路由处理程序执行

    return 'Viewing all posts'
  })
  .use((_, next) => {
    console.log('Inside middleware') // 步骤 1: 中间件执行
    return next()
  })
```

-----

## 路由标识符 (Route identifier)

每条路由都有一个**唯一的标识符**，您可以使用它在应用程序的其他地方引用该路由。例如，您可以使用 [构建器](https://www.google.com/search?q=%23url-builder) 为路由生成 URL，或使用 [`response.redirect()`](https://www.google.com/search?q=./response.md%23redirects) 方法**重定向**到路由。

默认情况下，**路由模式就是路由标识符**。但是，您可以使用 **`route.as` 方法**为路由分配一个独特的、易记的**名称**。

```ts
// title: start/routes.ts
router.get('users', () => {}).as('users.index') // 命名为 'users.index'

router.post('users', () => {}).as('users.store') // 命名为 'users.store'

router.delete('users/:id', () => {}).as('users.delete') // 命名为 'users.delete'
```

您现在可以在模板中或使用 URL 构建器，通过路由名称来构建 URL。

```ts
const url = router.builder().make('users.delete', [user.id])
```

```edge
<form
  method='POST'
  action="{{
    route('users.delete', [user.id], { formAction: 'delete' })
  }}"
></form>
```

-----

## 路由分组 (Grouping routes)

路由分组提供了一个便利层，用于**批量配置**嵌套在组内的路由。您可以使用 **`router.group` 方法**创建一组路由。

```ts
// title: start/routes.ts
router.group(() => {
  /**
   * 注册在回调函数内的所有路由
   * 都是该分组的一部分
   */
  router.get('users', () => {})
  router.post('users', () => {})
})
```

路由分组可以**相互嵌套**，AdonisJS 将根据应用设置的行为合并或覆盖属性。

```ts
// title: start/routes.ts
router.group(() => { // 外层分组
  router.get('posts', () => {})

  router.group(() => { // 内层分组
    router.get('users', () => {})
  })
})
```

### 在分组内添加路由前缀 (Prefixing routes inside a group)

分组内路由的 URI 模式可以使用 **`group.prefix` 方法**添加前缀。以下示例将为 `/api/users` 和 `/api/payments` URI 模式创建路由。

```ts
// title: start/routes.ts
router
  .group(() => {
    router.get('users', () => {}) // 最终 URI: /api/users
    router.get('payments', () => {}) // 最终 URI: /api/payments
  })
  .prefix('/api')
```

在**嵌套分组**的情况下，前缀将从外层分组应用到内层分组。以下示例将为 `/api/v1/users` 和 `/api/v1/payments` URI 模式创建路由。

```ts
// title: start/routes.ts
router
  .group(() => { // 外层分组: /api
    router
      .group(() => { // 内层分组: v1
        router.get('users', () => {}) // 最终 URI: /api/v1/users
        router.get('payments', () => {}) // 最终 URI: /api/v1/payments
      })
      .prefix('v1')
  })
  .prefix('api')
```

### 在分组内命名路由 (Naming routes inside a group)

与为路由模式添加前缀类似，您也可以使用 **`group.as` 方法**为分组内的路由名称添加前缀。

:::note

分组内的路由必须先有名称，然后才能为其添加前缀。

:::

```ts
// title: start/routes.ts
router
  .group(() => {
    router
      .get('users', () => {})
      .as('users.index') // 最终名称 - api.users.index
  })
  .prefix('api')
  .as('api')
```

在**嵌套分组**的情况下，名称将从外层分组前缀到内层分组。

```ts
// title: start/routes.ts
router
  .group(() => { // 外层分组: api
    router
      .get('users', () => {})
      .as('users.index') // 最终名称: api.users.index

    router
      .group(() => { // 内层分组: commerce
        router
          .get('payments', () => {})
          .as('payments.index') // 最终名称: api.commerce.payments.index
      })
      .as('commerce')
  })
  .prefix('api')
  .as('api')
```

### 对分组内路由应用中间件 (Applying middleware to routes inside a group)

您可以使用 **`group.use` 方法**为分组内的路由分配中间件。分组中间件在应用于分组内单个路由的中间件**之前**执行。

在**嵌套分组**的情况下，最外层分组的中间件将最先运行。换句话说，分组会将中间件**前置**到路由中间件栈。

另请参阅：[中间件指南](https://www.google.com/search?q=./middleware.md)

```ts
// title: start/routes.ts
router
  .group(() => {
    router
      .get('posts', () => {})
      .use((_, next) => {
        console.log('logging from route middleware') // 步骤 2
        return next()
      })
  })
  .use((_, next) => {
    console.log('logging from group middleware') // 步骤 1
    return next()
  })
```

-----

## 注册特定域名的路由 (Registering routes for a specific domain)

AdonisJS 允许您在**特定域名**下注册路由。当您的应用程序映射到多个域名并希望每个域名拥有不同的路由时，这会很有帮助。

在以下示例中，我们定义了两组路由。

  * 针对**任何域名/主机名**解析的路由。
  * 当域名/主机名与预定义的域名值匹配时才匹配的路由。

<!-- end list -->

```ts
// title: start/routes.ts
// 匹配所有域名
router.group(() => {
  router.get('/users', () => {})
  router.get('/payments', () => {})
})

// 仅在 blog.adonisjs.com 域名下匹配
router.group(() => {
  router.get('/articles', () => {})
  router.get('/articles/:id', () => {})
}).domain('blog.adonisjs.com')
```

一旦您部署了应用程序，带有显式域名的分组下的路由将**仅在请求的主机名为 `blog.adonisjs.com` 时**才匹配。

### 动态子域名 (Dynamic subdomains)

您可以使用 **`group.domain` 方法**指定**动态子域名**。与路由参数类似，域名的动态片段以**冒号 `:`** 开头。

在以下示例中，`tenant` 片段接受任何子域名，您可以使用 `HttpContext.subdomains` 对象访问其值。

```ts
// title: start/routes.ts
router
 .group(() => {
   router.get('users', ({ subdomains }) => {
     return `Listing users for ${subdomains.tenant}`
   })
 })
 .domain(':tenant.adonisjs.com') // 动态子域名
```

-----

## 从路由渲染 Edge 视图 (Render Edge view from a route)

如果您的路由处理程序**只渲染一个视图**，您可以使用 **`router.on().render()` 方法**。这是一个方便的快捷方式，无需定义显式处理程序即可渲染视图。

`render` 方法接受要渲染的 Edge 模板的名称。您可以选择性地将模板数据作为第二个参数传入。

:::warning

`route.on().render()` 方法仅在您配置了 [Edge 服务提供者](https://www.google.com/search?q=../views-and-templates/edgejs.md) 时才存在。

:::

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'

router.on('/').render('home')
router.on('about').render('about', { title: 'About us' })
router.on('contact').render('contact', { title: 'Contact us' })
```

## 从路由渲染 Inertia 视图 (Render Inertia view from a route)

如果您正在使用 **Inertia.js 适配器**，您可以使用 **`router.on().renderInertia()` 方法**来渲染 Inertia 视图。这是一个方便的快捷方式，无需定义显式处理程序即可渲染视图。

`renderInertia` 方法接受要渲染的 Inertia 组件的名称。您可以选择性地将组件数据作为第二个参数传入。

:::warning

`route.on().renderInertia()` 方法仅在您配置了 [Inertia 服务提供者](https://www.google.com/search?q=../views-and-templates/inertia.md) 时才存在。

:::

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'

router.on('/').renderInertia('home')
router.on('about').renderInertia('about', { title: 'About us' })
router.on('contact').renderInertia('contact', { title: 'Contact us' })
```

## 从路由重定向 (Redirect from a route)

如果您正在定义路由处理程序以将请求重定向到另一个路径或路由，您可以使用 **`router.on().redirect()`** 或 **`router.on().redirectToPath()`** 方法。

`redirect` 方法接受**路由标识符**。而 `redirectToPath` 方法接受一个**静态路径/URL**。

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'

// 重定向到另一条路由 (路由标识符)
router.on('/posts').redirect('/articles')

// 重定向到 URL (静态路径/URL)
router.on('/posts').redirectToPath('https://medium.com/my-blog')
```

### 转发参数 (Forwarding params)

在以下示例中，来自原始请求的 `id` 值将用于构建 `/articles/:id` 路由。因此，如果请求来自 `/posts/20`，它将被重定向到 `/articles/20`。

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'

// id 参数将从原始请求转发
router.on('/posts/:id').redirect('/articles/:id')
```

### 显式指定参数 (Explicitly specifying params)

您也可以将路由参数作为第二个参数**显式指定**。在这种情况下，当前请求的参数将被忽略。

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'

// 始终重定向到 /articles/1
router.on('/posts/:id').redirect('/articles/:id', {
  id: 1
})
```

### 带有查询字符串 (With query string)

重定向 URL 的查询字符串可以在选项对象中定义。

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'

router.on('/posts').redirect('/articles', {
  qs: {
    limit: 20,
    page: 1,
  }  
})
```

-----

## 当前请求路由 (Current request route)

可以使用 **`HttpContext.route`** 属性访问当前请求的路由。它包括**路由模式**、**名称**、**对其中间件存储的引用**以及**对路由处理程序的引用**。

```ts
// title: start/routes.ts
router.get('payments', ({ route }) => {
  console.log(route)
})
```

您还可以使用 **`request.matchesRoute` 方法**检查当前请求是否针对特定路由。该方法接受**路由 URI 模式**或**路由名称**。

```ts
// title: start/routes.ts
router.get('/posts/:id', ({ request }) => {
  if (request.matchesRoute('/posts/:id')) {
    // 匹配 URI 模式
  }
})
```

```ts
// title: start/routes.ts
router
  .get('/posts/:id', ({ request }) => {
    if (request.matchesRoute('posts.show')) {
        // 匹配路由名称
    }
  })
  .as('posts.show')
```

您还可以**匹配多条路由**。该方法会在找到第一个匹配项时立即返回 true。

```ts
if (request.matchesRoute(['/posts/:id', '/posts/:id/comments'])) {
  // 执行某些操作
}
```

-----

## AdonisJS 如何匹配路由 (How AdonisJS matches routes)

路由按照它们在路由文件中注册的**相同顺序**进行匹配。我们从最上面的路由开始匹配，并在**第一个匹配的路由**处停止。

如果您有两条相似的路由，则必须**先注册最具体的路由**。

在以下示例中，对 URL `/posts/archived` 的请求将由第一条路由（即 `/posts/:id`）处理，因为动态参数 `id` 将捕获 `archived` 值。

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'

// 路由 1: /posts/:id (动态参数) -> 会捕获 'archived'
router.get('posts/:id', () => {})
// 路由 2: /posts/archived (特定路由) -> 永远不会被匹配到
router.get('posts/archived', () => {})
```

可以通过**重新排序路由**来修复此行为，将最具体的路由放在带有动态参数的路由之前。

```ts
// title: start/routes.ts
// 路由 1: /posts/archived (特定路由) -> 首先被匹配到
router.get('posts/archived', () => {})
// 路由 2: /posts/:id (动态参数) -> 仅匹配其他情况
router.get('posts/:id', () => {})
```

### 处理 404 请求 (Handling 404 requests)

当找不到与当前请求的 URL 匹配的路由时，AdonisJS 会抛出一个 **404 异常**。

要向用户显示 404 页面，您可以在[全局异常处理程序](https://www.google.com/search?q=./exception_handling.md)中捕获 **`E_ROUTE_NOT_FOUND` 异常**并渲染模板。

```ts
// app/exceptions/handler.ts
import { errors } from '@adonisjs/core'
import { HttpContext, ExceptionHandler } from '@adonisjs/core/http'

export default class HttpExceptionHandler extends ExceptionHandler {
  async handle(error: unknown, ctx: HttpContext) {
    if (error instanceof errors.E_ROUTE_NOT_FOUND) {
      return ctx.view.render('errors/404')
    }
    
    return super.handle(error, ctx)
  }
}
```

-----

## URL 构建器 (URL builder)

您可以使用 URL 构建器为应用程序中**预定义的路由创建 URL**。例如，在 Edge 模板中创建表单操作 URL，或创建 URL 以将请求重定向到另一条路由。

**`router.builder` 方法**创建 [构建器](https://github.com/adonisjs/http-server/blob/main/src/router/lookup_store/url_builder.ts) 类的一个实例，您可以使用构建器的流畅 API 查找路由并为其创建 URL。

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'
const PostsController = () => import('#controllers/posts_controller')

router
  .get('posts/:id', [PostsController, 'show'])
  .as('posts.show') // 命名路由: posts.show
```

您可以按如下方式为 `posts.show` 路由生成 URL。

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'

router
  .builder()
  .params([1]) // 位置参数
  .make('posts.show') // /posts/1

router
 .builder()
 .params([20])
 .make('posts.show') // /posts/20
```

参数可以指定为**位置参数数组**。或者您可以将它们定义为**键值对**。

```ts
// title: start/routes.ts
router
 .builder()
 .params({ id: 1 }) // 键值对
 .make('posts.show') // /posts/1
```

### 定义查询参数 (Defining query parameters)

查询参数可以使用 **`builder.qs` 方法**定义。该方法接受一个键值对对象，并将其序列化为查询字符串。

```ts
// title: start/routes.ts
router
  .builder()
  .qs({ page: 1, sort: 'asc' })
  .make('posts.index') // /posts?page=1&sort=asc
```

查询字符串是使用 **[qs](https://www.npmjs.com/package/qs) npm 包**序列化的。您可以在 `config/app.ts` 文件中的 `http` 对象下[配置其设置](https://github.com/adonisjs/http-server/blob/main/src/define_config.ts#L49-L54)。

```ts
// title: config/app.js
http: defineConfig({
  qs: {
    stringify: {
      //  配置 qs 库的选项
    }
  }
})
```

### URL 前缀 (Prefixing URL)

您可以使用 **`builder.prefixUrl` 方法**为输出添加一个基础 URL 前缀。

```ts
// title: start/routes.ts
router
  .builder()
  .prefixUrl('https://blog.adonisjs.com')
  .params({ id: 1 })
  .make('posts.show') // https://blog.adonisjs.com/posts/1
```

### 生成签名 URL (Generating signed URLs)

**签名 URL (Signed URLs)** 是附加了**签名查询字符串**的 URL。签名用于验证 URL 在生成后是否被篡改。

例如，您有一个用于取消用户订阅时事通讯的 URL。该 URL 包含 `userId`，可能如下所示。

```
/unsubscribe/231
```

为了防止有人将用户 id 从 `231` 更改为其他值，您可以**签署**此 URL，并在处理此路由的请求时验证签名。

```ts
// title: start/routes.ts
router.get('unsubscribe/:id', ({ request, response }) => {
  if (!request.hasValidSignature()) {
    return response.badRequest('Invalid or expired URL') // 签名无效或过期
  }
  
  // 移除订阅
}).as('unsubscribe')
```

您可以使用 **`makeSigned` 方法**来创建签名 URL。

```ts
// title: start/routes.ts
router
  .builder()
  .prefixUrl('https://blog.adonisjs.com')
  .params({ id: 231 })
  // highlight-start
  .makeSigned('unsubscribe') // 生成带有签名的 URL
  // highlight-end
```

#### 签名 URL 过期 (Signed URL expiration)

您可以使用 `expiresIn` 选项生成在给定持续时间后**过期**的签名 URL。该值可以是**毫秒数**或**时间表达式字符串**。

```ts
// title: start/routes.ts
router
  .builder()
  .prefixUrl('https://blog.adonisjs.com')
  .params({ id: 231 })
  // highlight-start
  .makeSigned('unsubscribe', {
    expiresIn: '3 days' // 3 天后过期
  })
  // highlight-end
```

### 禁用路由查找 (Disabling route lookup)

URL 构建器会对传递给 `make` 和 `makeSigned` 方法的路由标识符执行**路由查找**。

如果您想为在 AdonisJS 应用程序**外部**定义的路由创建 URL，您可以禁用路由查找，并将**路由模式**传递给 `make` 和 `makeSigned` 方法。

```ts
// title: start/routes.ts
router
  .builder()
  .prefixUrl('https://your-app.com')
  .disableRouteLookup() // 禁用路由查找
  .params({ token: 'foobar' })
  .make('/email/verify/:token') // /email/verify/foobar
```

### 为特定域名的路由生成 URL (Making URL for routes under a domain)

您可以使用 **`router.builderForDomain` 方法**为在特定域名下注册的路由创建 URL。该方法接受您在定义路由时使用的**路由模式**。

```ts
// title: start/routes.ts
import router from '@adonisjs/core/services/router'
const PostsController = () => import('#controllers/posts_controller')

router.group(() => {
  router
    .get('/posts/:id', [PostsController, 'show'])
    .as('posts.show')
}).domain('blog.adonisjs.com')
```

您可以按如下方式为 `blog.adonisjs.com` 域名下的 `posts.show` 路由创建 URL。

```ts
// title: start/routes.ts
router
  .builderForDomain('blog.adonisjs.com') // 指定域名
  .params({ id: 1 })
  .make('posts.show') // https://blog.adonisjs.com/posts/1
```

### 在模板中生成 URL (Generating URLs inside templates)

您可以在模板中使用 **`route`** 和 **`signedRoute` 方法**来使用 URL 构建器生成 URL。

另请参阅：[Edge 辅助函数参考](https://www.google.com/search?q=../references/edge.md%23routesignedroute)

```edge
<a href="{{ route('posts.show', [post.id]) }}">
  View post
</a>
```

```edge
<a href="{{
  signedRoute('unsubscribe', [user.id], {
    expiresIn: '3 days',
    prefixUrl: 'https://blog.adonisjs.com'    
  })
}}">
  Unsubscribe
</a>
```

-----

## 扩展路由器 (Extending router)

您可以使用 **宏 (macros)** 和 **getter** 向不同的路由器类添加自定义属性。如果您对宏的概念不熟悉，请务必先阅读 [扩展 AdonisJS 指南](https://www.google.com/search?q=../concepts/extending_the_framework.md)。

以下是您可以扩展的类列表。

### Router

[Router 类](https://github.com/adonisjs/http-server/blob/main/src/router/main.ts)包含用于创建路由、路由分组或路由资源的顶级方法。该类的实例可通过**路由器服务**获得。

```ts
import { Router } from '@adonisjs/core/http'

Router.macro('property', function (this: Router) {
  return value
})
Router.getter('propertyName', function (this: Router) {
  return value
})
```

```ts
// title: types/http.ts
declare module '@adonisjs/core/http' {
  export interface Router {
    property: valueType
  }
}
```

### Route

[Route 类](https://github.com/adonisjs/http-server/blob/main/src/router/route.ts)代表**单个路由**。一旦您调用 `router.get`、`router.post` 和其他类似方法，就会创建 Route 类的一个实例。

```ts
import { Route } from '@adonisjs/core/http'

Route.macro('property', function (this: Route) {
  return value
})
Router.getter('property', function (this: Route) {
  return value
})
```

```ts
// title: types/http.ts
declare module '@adonisjs/core/http' {
  export interface Route {
    property: valueType
  }
}
```

### RouteGroup

[RouteGroup 类](https://github.com/adonisjs/http-server/blob/main/src/router/group.ts)代表**一组路由**。一旦您调用 `router.group` 方法，就会创建 RouteGroup 类的一个实例。

您可以在宏或 getter 实现内部使用 `this.routes` 属性访问分组的路由。

```ts
import { RouteGroup } from '@adonisjs/core/http'

RouteGroup.macro('property', function (this: RouteGroup) {
  return value
})
RouteGroup.getter('property', function (this: RouteGroup) {
  return value
})
```

```ts
// title: types/http.ts
declare module '@adonisjs/core/http' {
  export interface RouteGroup {
    property: valueType
  }
}
```

### RouteResource

[RouteResource 类](https://github.com/adonisjs/http-server/blob/main/src/router/resource.ts)代表**一组用于资源的路由**。一旦您调用 `router.resource` 方法，就会创建 RouteResource 类的一个实例。

您可以在宏或 getter 实现内部使用 `this.routes` 属性访问资源的路由。

```ts
import { RouteResource } from '@adonisjs/core/http'

RouteResource.macro('property', function (this: RouteResource) {
  return value
})
RouteResource.getter('property', function (this: RouteResource) {
  return value
})
```

```ts
// title: types/http.ts
declare module '@adonisjs/core/http' {
  export interface RouteResource {
    property: valueType
  }
}
```

### BriskRoute

[BriskRoute 类](https://github.com/adonisjs/http-server/blob/main/src/router/brisk.ts)代表**没有显式处理程序的路由**。一旦您调用 `router.on` 方法，就会创建 BriskRoute 类的一个实例。

您可以在宏或 getter 内部调用 `this.setHandler` 方法来分配路由处理程序。

```ts
import { BriskRoute } from '@adonisjs/core/http'

BriskRoute.macro('property', function (this: BriskRoute) {
  return value
})
BriskRouter.getter('property', function (this: BriskRoute) {
  return value
})
```

```ts
// title: types/http.ts
declare module '@adonisjs/core/http' {
  export interface BriskRoute {
    property: valueType
  }
}
```